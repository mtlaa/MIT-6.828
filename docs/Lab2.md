# Lab 2: 内存管理

## 引言
在这个实验中，你将为你的操作系统编写内存管理的代码。内存管理有两个组件。

第一个组件是内核的物理内存分配器，使内核能够分配内存然后再释放它。分配器将以 4096B 为单位运行，称为页。你的任务是维护数据结构，这个数据结构记录哪些物理页面是空闲的，哪些是已分配的，以及有多少进程共享每个分配的页面。你还将编写例程来分配和释放内存页面。

第二个组件是虚拟内存的管理，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86 硬件的内存管理单元 (MMU) 在指令使用内存时通过查找页表来执行映射。你将根据我们提供的规范修改JOS去设置MMU的页表。

## 开始
在这个和未来的实验中，你将逐步构建你的内核。我们也会提供给你一些附加资源。

分支`lab2`提供了几个新的源文件，需要把lab1中的更改合并到lab2中：
* inc/memlayout.h
* kern/pmap.c
* kern/pmap.h
* kern/kclock.h
* kern/kclock.c

`memlayout.h` 描述了您必须通过修改 `pmap.c` 来​​实现的虚拟地址空间的布局。 `memlayout.h` 和 `pmap.h` 定义了 `PageInfo` 结构，您将使用它来跟踪哪些物理内存页面是空闲的。 `kclock.c` 和 `kclock.h` 操纵 PC's battery-backed clock 和 CMOS RAM 硬件，其中 BIOS 记录 PC 包含的物理内存总量等。 `pmap.c` 中的代码需要读取这个设备硬件，以便计算出有多少物理内存，但是这部分代码已经为你完成了：您不需要了解 CMOS 硬件工作的细节。

请特别注意 `memlayout.h` 和 `pmap.h`，因为本实验要求您使用并理解它们包含的许多定义。您可能还想查看 `inc/mmu.h`，因为它还包含许多对本实验有用的定义。

## 实验要求
在本实验和后续实验中，完成实验中描述的所有常规练习和至少一个挑战问题。此外，写下对实验提出的问题的简短答案，并简短描述您为解决所选挑战问题所做的工作。

这个实验的目标应该是完善`pmap.c`

可以在`lab`目录下使用`make grade`进行评分。

# Part 1：物理内存管理
操作系统必须追踪物理内存的哪些部分是空闲的，哪些部分正在被使用。JOS使用页面粒度管理PC的物理内存，以便它可以使用MMU映射和保护每块分配的内存。

你现在将编写物理页面分配器。它使用 `struct PageInfo` 对象的链表跟踪哪些页面是空闲的（与 xv6 不同，这些对象本身不嵌入空闲页面中），每个对象对应一个物理页面。您需要先编写物理页面分配器，然后才能编写其余的虚拟内存实现，因为您的页表管理代码需要分配物理内存来存储页表（页表存储在内存中，需要为页表分配物理内存）。

> **练习1** 在文件 `kern/pmap.c` 中，你必须实现以下函数的代码。    
> `boot_alloc()`   
> `mem_init()` (only up to the call to check_page_free_list(1))   
> `page_init()`   
> `page_alloc()`   
> `page_free()`  
> 
> `check_page_free_list()` 和 `check_page_alloc()` 测试你的物理页面分配器。你应该启动 JOS 并查看 `check_page_alloc()` 是否报告成功。修复您的代码以使其通过。您可能会发现添加自己的 `assert()` 对验证自己的的假设是否正确很有帮助。

这个实验以及所有 6.828 的实验，都需要你做一些侦探工作来弄清楚你需要做什么。该练习没有指出你必须添加到 JOS 的代码的所有细节。也就是说对源码的注释要多加注意，注释里会有一些提示以及指出需要你要添加的代码。

# Part 2：虚拟内存
在做任何其他事情之前，请先熟悉 x86 的保护模式内存管理架构：即分段和页面转换。

> **练习2** 如果您还没有这样做，请查看 [Intel 80386 参考手册](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)的第 5 章和第 6 章。仔细阅读有关页面转换和基于页面的保护的部分（5.2 和 6.4）。我们建议您也浏览一下关于细分的部分；虽然 JOS 使用分页硬件进行虚拟内存和保护，但在 x86 上不能禁用段转换和基于段的保护，因此您需要对它有一个基本的了解。

## 虚拟、线性和物理地址
在 x86 术语中，虚拟地址由段选择器和段内的偏移量组成。线性地址是在段翻译之后但在页翻译之前得到的。物理地址是在段和面翻译之后最终得到的，并且最终通过硬件总线输出到 RAM 用以访存。
```

           Selector  +--------------+         +-----------+
          ---------->|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |-------->|           |---------->  RAM
            Offset   |  Mechanism   |         | Mechanism |
          ---------->|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical
```

C 语言中的指针是虚拟地址的`offset`部分。在 `boot/boot.S` 中，我们设置了一个全局描述符表 (GDT)，它通过将所有段的基地址设置为 `0`,所有段的段长设置为 `0xffffffff` 来有效地禁用段翻译。因此`selector`没有任何作用，线性地址总是等于虚拟地址的偏移量。在lab 3 中，我们将不得不与分段进行更多交互以设置权限级别，但至于内存翻译，我们可以在整个 JOS 实验中忽略分段，只关注页面翻译（两级页表）。

回想一下，在 lab 1 的 Part 3 中，我们安装了一个简单的页表，这样内核就可以在其链接地址 `0xf0100000` 处运行，即使它实际上是加载到 ROM BIOS 上方 `0x00100000` 处的物理内存中。这个页表只映射了 4MB 的内存。在本实验中你要为JOS设置的虚拟地址空间布局中，我们将扩展它以映射从虚拟地址`0xf0000000`开始的**前256MB物理内存**，并映射虚拟地址空间的其他一些区域。

> **练习3** 虽然 GDB 只能通过虚拟地址访问 QEMU 的内存，但在设置虚拟内存时能够检查物理内存通常很有用。查看实验工具指南中的 [QEMU 监视器命令](https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu)，尤其是 `xp` 命令，它可以让您检查物理内存。要访问 QEMU 监视器，请在qemu终端中按 `Ctrl-a c`（相同的绑定返回到串行控制台）。     
> 使用 QEMU 监视器中的 `xp` 命令和 GDB 中的 `x` 命令来检查相应物理和虚拟地址的内存，并确保您看到相同的数据。     
> 我们的 QEMU 补丁版本提供了一个 `info pg` 命令，它也可能被证明是有用的：它显示了当前页表的紧凑但详细的表示，包括所有映射的内存范围、权限和标志。 Stock QEMU 还提供了一个 `info mem` 命令，该命令显示了映射哪些虚拟地址范围以及具有哪些权限的概览。

从 CPU 上执行的代码来看，一旦我们处于保护模式（在 `boot/boot.S` 中设置），就无法直接使用线性或物理地址。所有内存引用都被解释为虚拟地址并由 MMU 翻译，这意味着 C 语言中的所有指针都是虚拟地址。

JOS 内核通常需要将地址作为不透明的值或​​整数来操作，不能解引用它们，例如在物理内存分配器中。有时这些值是虚拟地址，有时这些值是物理地址。为了帮助区分代码，JOS 源代码区分了两种情况：类型 `uintptr_t` 表示不透明的虚拟地址，而 `physaddr_t` 表示物理地址。这两种类型实际上只是 32 位无符号整数 (`uint32_t`) 的同义词，因此编译器不会阻止您将一种类型分配给另一种类型！由于它们是整数类型（不是指针），如果您尝试解引用它们，编译器会报错。

JOS内核可以通过将`uintptr_t`强制转换为指针类型来解引用虚拟地址。相反，内核不能合理地解引用物理地址，因为 MMU 会翻译所有内存引用。如果您将 `physaddr_t` 转换为指针并解引用它，你可能能够加载和存储到一个结果地址（硬件会把它解释为一个虚拟地址），但是你可能不会得到你想要的内存位置。**也就是MMU无法区分解引用的是物理地址还是虚拟地址，都会把地址进行变换（翻译）。所以我们不应该解引用物理地址。**

总结：
| C type | Address type |
| :------ | :-------: |
| T*     |	Virtual     |
| uintptr_t  |	Virtual |
| physaddr_t  |	Physical |

> **Question 1** 假设下面的 JOS 内核代码是正确的，变量 `x` 应该有什么类型，`uintptr_t` 还是 `physaddr_t`？
> ```c
>   mystery_t x;
>	char* value = return_a_pointer();
>	*value = 10;
>	x = (mystery_t) value;
>```

JOS内核有时需要读取或修改它只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。然而，内核不能绕过虚拟地址转换，因此不能直接加载和存储到物理地址。JOS将所有的物理内存从物理地址`0`开始重新映射到虚拟地址`0xf0000000`的原因之一是为了帮助内核读写它只知道物理地址的内存。为了将物理地址转换为内核可以实际读写的虚拟地址，内核必须在物理地址上加上`0xf0000000`，以便在重新映射的区域中找到其对应的虚拟地址。你应该使用`KADDR(pa)`来做这个加法。

JOS 内核有时还需要能够在给定存储内核数据结构的内存虚拟地址的情况下找到物理地址。内核全局变量和由 `boot_alloc()` 分配的内存位于内核加载的区域，从 `0xf0000000` 开始，即我们映射所有物理内存的区域。因此，要将这个区域中的虚拟地址转换为物理地址，内核可以简单地减去 `0xf0000000`。您应该使用 `PADDR(va)` 进行减法。

## 引用计数
在未来的实验中，您通常会将相同的物理页面同时映射到多个虚拟地址（或多个环境的地址空间）。您将在与物理页面对应的 `struct PageInfo` 的 `pp_ref` 字段中记录对每个物理页面的引用次数。当一个物理页面的计数变为零时，该页面可以被释放，因为它不再被使用。一般来说，这个计数应该等于物理页所对应的页表项在所有页表中出现在`UTOP`之下的次数（`UTOP`之上的映射大多是内核在启动时设置的，永远不应该被释放，所以不需要引用计数）。我们还将使用它来跟踪页目录对页表页的引用计数。

使用 `page_alloc` 时要小心。它返回的页面的引用计数始终为 0，因此一旦您对返回的页面进行了某些操作（例如将其插入页表），`pp_ref` 就应该增加。有时这由其他函数（例如 `page_insert`）处理，有时调用 `page_alloc` 的函数必须直接执行此操作。

## 页表管理
现在您将编写一组例程来管理页表：插入和删除线性地址到物理物理地址的映射（即插入和删除页表项），并在需要时创建页表页。

页表项的格式     
![](https://pdos.csail.mit.edu/6.828/2018/readings/i386/fig5-10.gif)

> **练习4** 在文件 `kern/pmap.c` 中，您必须实现以下函数的代码。      
> `pgdir_walk()`    
> `boot_map_region()`    
> `page_lookup()`     
> `page_remove()`     
> `page_insert()`     
> 从 `mem_init()` 调用的 `check_page()` 测试您的页表管理例程。在继续 Part 3 之前，您应该确保它报告成功。


# Part 3: 内核地址空间
JOS 将处理器的 32 位线性地址空间分为两部分(高地址部分和低地址部分)。我们在 lab 3 中加载和运行的用户环境（进程）将控制低地址部分的布局和内容，而内核始终保持对高地址部分的完全控制。它们之间的分隔线由 `inc/memlayout.h` 中的符号 `ULIM` 定义，为内核保留大约 256MB 的虚拟地址空间。这就解释了为什么我们需要在 lab 1 中给内核提供如此高的链接地址：否则内核的虚拟地址空间中将没有足够的空间来同时映射到它下面的用户环境中。

您会发现参考 `inc/memlayout.h` 中的 JOS 内存布局图对本部分和以后的实验很有帮助。

## 权限和故障隔离
由于内核和用户内存都存在于各自环境的地址空间中，我们将不得不在 x86 页表中使用权限位，以允许用户代码仅访问地址空间的用户部分。否则用户代码中的 Bugs 可能会覆盖（写内核）内核数据，导致内核崩溃或更微妙的故障；用户代码也可能能够窃取其他环境的私有数据。请注意，可写权限位（`PTE_W`）会影响用户和内核代码！

用户环境将无权访问 `ULIM` 之上的任何内存，只有内核能够读取和写入这些内存。对于地址范围`[UTOP,ULIM)`，内核和用户环境都可以读但不能写。这个地址范围用于向用户环境公开某些只读的内核数据结构。最后，`UTOP` 下面的地址空间是供用户环境使用的；用户环境将设置访问此内存的权限。

## 初始化内核地址空间
现在，你应该使用`inc/memlayout.h`中的内存布局设置 `UTOP` 上方的地址空间，这是地址空间的内核部分。您将使用刚刚编写的函数（练习4）来设置适当的线性地址到物理地址映射。

> **练习5** 在`mem_init()`中的` check_page()`调用后完成缺失的代码。     
> 你的代码应该能通过 `check_kern_pgdir()` 和 `check_page_installed_pgdir()` 检查。

