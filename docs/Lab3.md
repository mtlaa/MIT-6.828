# Lab 3: 用户环境

# 引言
在本实验中，您将实现运行受保护的用户模式环境（即“进程”）所需的基本内核工具。您将增强 JOS 内核设置数据结构以跟踪用户环境、创建单个用户环境、将程序映像加载到其中并开始运行。您还将使 JOS 内核处理用户环境运行时的任何系统调用并处理它导致的任何其他异常。

注意：在本实验中，环境(*environment*)和进程(*process*)这两个术语是可以互换的——它们都指的是允许你运行的程序的抽象。我们引入术语“环境”而不是传统术语“进程”是为了强调 JOS 环境和 UNIX 进程提供不同的接口，并且不提供相同的语义。

## 开始
合并`origin/lab3`分支，Lab 3 包含一些新的源文件，你应该浏览它们：
* `inc/env.h`	    用户模式环境的公共定义    
        `trap.h`	陷阱(陷入，trap)处理的公共定义    
        `syscall.h`	从用户环境到内核的系统调用的公共定义    
        `lib.h`	    用户模式支持库的公共定义   
* `kern/env.h`	    用户模式环境的内核私有定义      
        `env.c`	    实现用户模式环境的内核代码     
        `trap.h`	陷阱(陷入，trap)处理的内核私有定义     
        `trap.c`	陷阱(陷入，trap)处理的代码      
        `trapentry.S`	汇编语言陷阱处理程序入口点     
        `syscall.h`	系统调用的内核私有定义       
        `syscall.c`	实现系统调用的代码      
* `lib/Makefrag`	用于构建用户模式库`obj/lib/libjos.a`的 `Makefile` 片段      
    `entry.S`	用户环境的汇编语言入口点     
    `libmain.c`	从 `entry.S` 调用的用户模式库设置代码     
    `syscall.c`	用户模式系统调用的存根函数（stub function 就是存根函数，也就是模拟函数：在你真正实现函数功能前，你将结果返回，模拟真实的函数调用。）    
    `console.c`	提供控制台 I/O 的`putchar` 和 `getchar` 的用户模式实现     
    `exit.c`	`exit` 的用户模式实现    
    `panic.c`	`panic` 的用户模式实现    

## 实验要求
这个实验分为A、B两部分。先完成 Part A 的代码，在完成 Part B 的代码。

与实验 2 一样，您需要完成实验中描述的所有常规练习和至少一个挑战题。

## 内联汇编
在本实验中，您可能会发现 GCC 的内联汇编语言（Inline Assembly）功能很有用，尽管也可以在不使用它的情况下完成本实验。但至少，您需要能够理解我们提供给您的源代码中已经存在的内联汇编语言（`asm`语句）的片段。您可以在课程参考资料页面上找到有关 [GCC 内联汇编语言的信息](https://pdos.csail.mit.edu/6.828/2018/reference.html)。

# Part A: 用户环境和异常处理
新包含的文件 `inc/env.h` 中包含 JOS 中用户环境的基本定义，现在阅读它。内核使用 `Env` 数据结构来跟踪每个用户环境。在本实验中，您最初将只创建一个环境，但您需要设计 JOS 内核以支持多环境；lab 4 将通过允许用户环境`fork`其他环境来利用此功能。

正如您在 `kern/env.c` 中看到的，内核维护三个与环境有关的主要全局变量：
```c
struct Env *envs = NULL;		// 所有环境
struct Env *curenv = NULL;		// 当前环境
static struct Env *env_free_list;	// 空闲环境列表
```

一旦 JOS 启动并运行，`envs` 指针就会指向一个表示系统中所有环境的 `Env` 结构数组。在我们的设计中，JOS 内核将支持最多同时运行 `NENV` 个环境，尽管在任何给定时间运行的环境通常要少得多（`NENV` 是 `inc/env.h` 中定义的常量）。一旦分配，`envs`数组将会包含`NENV` 个可能环境的每个 `Env` 数据结构的单个实例。

JOS 内核将所有不活动的 `Env` 结构保存在 `env_free_list` 中。这种设计允许轻松分配和释放环境，因为它们只需添加到空闲列表或从空闲列表中删除。

内核使用 `curenv` 指针在任何给定时间跟踪当前执行的环境。在启动期间，运行第一个环境之前，`curenv` 最初设置为 `NULL`。

## 环境状态
