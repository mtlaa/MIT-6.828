# Lab 3: 用户环境

# 引言
在本实验中，您将实现运行受保护的用户模式环境（即“进程”）所需的基本内核工具。您将增强 JOS 内核设置数据结构以跟踪用户环境、创建单个用户环境、将程序映像加载到其中并开始运行。您还将使 JOS 内核处理用户环境运行时的任何系统调用并处理它导致的任何其他异常。

注意：在本实验中，环境(*environment*)和进程(*process*)这两个术语是可以互换的——它们都指的是允许你运行的程序的抽象。我们引入术语“环境”而不是传统术语“进程”是为了强调 JOS 环境和 UNIX 进程提供不同的接口，并且不提供相同的语义。

## 开始
合并`origin/lab3`分支，Lab 3 包含一些新的源文件，你应该浏览它们：
* `inc/env.h`	    用户模式环境的公共定义    
        `trap.h`	陷阱(陷入，trap)处理的公共定义    
        `syscall.h`	从用户环境到内核的系统调用的公共定义    
        `lib.h`	    用户模式支持库的公共定义   
* `kern/env.h`	    用户模式环境的内核私有定义      
        `env.c`	    实现用户模式环境的内核代码     
        `trap.h`	陷阱(陷入，trap)处理的内核私有定义     
        `trap.c`	陷阱(陷入，trap)处理的代码      
        `trapentry.S`	汇编语言陷阱处理程序入口点     
        `syscall.h`	系统调用的内核私有定义       
        `syscall.c`	实现系统调用的代码      
* `lib/Makefrag`	用于构建用户模式库`obj/lib/libjos.a`的 `Makefile` 片段      
    `entry.S`	用户环境的汇编语言入口点     
    `libmain.c`	从 `entry.S` 调用的用户模式库设置代码     
    `syscall.c`	用户模式系统调用的存根函数（stub function 就是存根函数，也就是模拟函数：在你真正实现函数功能前，你将结果返回，模拟真实的函数调用。）    
    `console.c`	提供控制台 I/O 的`putchar` 和 `getchar` 的用户模式实现     
    `exit.c`	`exit` 的用户模式实现    
    `panic.c`	`panic` 的用户模式实现    

## 实验要求
这个实验分为A、B两部分。先完成 Part A 的代码，在完成 Part B 的代码。

与实验 2 一样，您需要完成实验中描述的所有常规练习和至少一个挑战题。

## 内联汇编
在本实验中，您可能会发现 GCC 的内联汇编语言（Inline Assembly）功能很有用，尽管也可以在不使用它的情况下完成本实验。但至少，您需要能够理解我们提供给您的源代码中已经存在的内联汇编语言（`asm`语句）的片段。您可以在课程参考资料页面上找到有关 [GCC 内联汇编语言的信息](https://pdos.csail.mit.edu/6.828/2018/reference.html)。

# Part A: 用户环境和异常处理
新包含的文件 `inc/env.h` 中包含 JOS 中用户环境的基本定义，现在阅读它。内核使用 `Env` 数据结构来跟踪每个用户环境。在本实验中，您最初将只创建一个环境，但您需要设计 JOS 内核以支持多环境；lab 4 将通过允许用户环境`fork`其他环境来利用此功能。

正如您在 `kern/env.c` 中看到的，内核维护三个与环境有关的主要全局变量：
```c
struct Env *envs = NULL;		// 所有环境
struct Env *curenv = NULL;		// 当前环境
static struct Env *env_free_list;	// 空闲环境列表
```

一旦 JOS 启动并运行，`envs` 指针就会指向一个表示系统中所有环境的 `Env` 结构数组。在我们的设计中，JOS 内核将支持最多同时运行 `NENV` 个环境，尽管在任何给定时间运行的环境通常要少得多（`NENV` 是 `inc/env.h` 中定义的常量）。一旦分配，`envs`数组将会包含`NENV` 个可能环境的每个 `Env` 数据结构的单个实例。

JOS 内核将所有不活动的 `Env` 结构保存在 `env_free_list` 中。这种设计允许轻松分配和释放环境，因为它们只需添加到空闲列表或从空闲列表中删除。

内核使用 `curenv` 指针在任何给定时间跟踪当前执行的环境。在启动期间，运行第一个环境之前，`curenv` 最初设置为 `NULL`。

## 环境状态
`Env` 结构在 `inc/env.h` 中定义如下（在未来的实验中会添加更多字段）：
```c
struct Env {
	struct Trapframe env_tf;	// Saved registers
	struct Env *env_link;		// Next free Env
	envid_t env_id;			// Unique environment identifier
	envid_t env_parent_id;		// env_id of this env's parent
	enum EnvType env_type;		// Indicates special system environments
	unsigned env_status;		// Status of the environment
	uint32_t env_runs;		// Number of times environment has run

	// Address space
	pde_t *env_pgdir;		// Kernel virtual address of page dir
};
```

以下是 `Env` 中各字段的用途：    
* `env_tf`：`Trapframe`结构在 `inc/trap.h` 中定义，在环境未运行时(即当内核或其他环境正在运行时)保存环境的寄存器值。当从用户模式切换到内核模式时，内核会保存这些，以便以后可以从中断的地方恢复环境。     
* `env_link`：这是 `env_free_list` 中下一个空闲环境 `Env` 的指针。 `env_free_list` 指向列表中的第一个空闲环境。    
* `env_id`：内核在此处存储一个值，该值唯一标识当前使用此 `Env` 结构的环境（即，使用 `envs` 数组中的此特定插槽）。该用户环境终止后，内核可能会将相同的 `Env` 结构重新分配给不同的环境 --- 但新环境将具有与旧环境不同的 `env_id`，即使新环境正在重新使用 `envs` 数组中的相同插槽。      
* `env_parent_id`：内核在此处存储创建此环境的环境的 `env_id`,即该环境的父环境的id。通过这种方式，环境可以形成“家谱”，这将有助于允许哪些环境对谁做什么的安全决策。     
* `env_type`：这用于区分特殊环境。对于大多数环境，它将是 `ENV_TYPE_USER`。我们将在以后的实验中为特殊系统服务环境介绍更多类型。     
* `env_status`：此变量包含以下值之一：
   * `ENV_FREE`:表示该 `Env` 结构处于非活动状态，因此位于 `env_free_list` 上。     
   * `ENV_RUNNABLE`:指示该 `Env` 结构代表正在等待上处理器运行的环境。（就绪态）   
   * `ENV_RUNNING`:指示该`Env`结构代表正在运行的环境。（运行态）     
   * `ENV_NOT_RUNNABLE`:指示该 `Env` 结构代表当前正处于活动状态的环境，但它当前尚未准备好运行：例如，因为它正在等待来自另一个环境的进程间通信(IPC)。（阻塞态、等待态）       
   * `ENV_DYING`:指示该 `Env` 结构代表一个僵尸环境。僵尸环境将在下一次陷入内核时被释放。在 Lab 4 之前我们不会使用这个标志。    
 * `env_pgdir`：这个变量保存了这个环境的页目录的内核虚拟地址。    
  
与 Unix 进程一样，JOS 环境结合了“线程”和“地址空间”的概念。线程主要由保存的寄存器（`env_tf` 字段）定义，地址空间由 `env_pgdir` 指向的页目录和页表定义。要运行环境，内核必须使用保存的寄存器和适当的地址空间来设置 CPU。

我们的 `struct Env` 类似于 xv6 中的 `struct proc`。两种结构都在 `Trapframe` 结构中保存环境（即进程）的用户模式寄存器状态。在 JOS 中，各个环境不像 xv6 中的进程那样拥有自己的内核堆栈。内核中一次只能有一个活动的 JOS 环境，因此 JOS 只需要一个内核堆栈。

## 分配环境数组
在实验 2 中，您在 `mem_init()` 中为 `pages[]` 数组分配了内存，这是内核用来跟踪哪些页是空闲的，哪些页是空闲的。您现在需要进一步修改 `mem_init()` 以分配一个类似的 `Env` 结构数组，称为 `envs`。

> **练习1** 修改 `kern/pmap.c` 中的 `mem_init()` 以分配和映射 `envs` 数组。该数组由`NENV` 个 `Env` 结构的实例组成，就像您分配 `pages` 数组的方式一样。与 `pages` 数组一样，内存支持环境也应该在 `UENVS`（在 `inc/memlayout.h` 中定义）以用户只读方式映射，以便用户进程可以从该数组中读取。

## 创建和运行环境
您现在将在 `kern/env.c` 中编写运行用户环境所需的代码。因为我们还没有文件系统，所以我们将设置内核以加载嵌入内核本身的静态二进制镜像。 JOS 将此二进制文件作为 ELF 可执行镜像嵌入内核中。

Lab 3 的`GNUmakefile` 在 `obj/user/` 目录中生成许多二进制镜像。如果您查看 `kern/Makefrag`，您会注意到一些将这些二进制文件直接“链接”到内核可执行文件中的操作，就好像它们是 `.o` 文件一样。链接器命令行上的 `-b binary`选项导致这些文件作为“原始”未解释的二进制文件而不是编译器生成的常规 `.o` 文件链接。（就链接器而言，这些文件根本不必是 ELF 镜像——它们可以是任何东西，例如文本文件或图片！）如果您在构建内核后查看 `obj/kern/kernel.sym`，您会注意到，链接器“神奇地”生成了许多名称晦涩的有趣符号，例如 `_binary_obj_user_hello_start`、`_binary_obj_user_hello_end` 和 `_binary_obj_user_hello_size`。链接器通过修改二进制文件的文件名来生成这些符号名；这些符号为常规内核代码提供了一种引用嵌入式二进制文件的方法。

在 `kern/init.c` 中的 `i386_init()` 中，您将看到在环境中运行这些二进制镜像之一的代码。但是，设置用户环境的关键函数并不完整；您需要填写它们。

> **练习2** 在文件`env.c`中，完成以下函数的代码：     
> `env_init()`：初始化 `envs` 数组中的所有 `Env` 结构，并将它们添加到 `env_free_list` 中。还调用 `env_init_percpu`，它将分段硬件配置为 *特权级别 0（内核）* 和 *特权级别 3（用户）* 的单独段。     
> `env_setup_vm()`：为新环境分配页目录并初始化新环境地址空间的内核部分。      
> `region_alloc()`:为环境分配和映射物理内存。     
> `load_icode()`：您将需要解析一个 ELF 二进制映像，就像引导加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。     
> `env_create()`：使用 `env_alloc` 分配一个环境并调用 `load_icode` 将 ELF 二进制文件加载到其中。     
> `env_run()`：启动以用户模式运行的给定环境。     
> 在编写这些函数时，您可能会发现新的 `cprintf` 格式化输出 `%e` 很有用——它会打印与错误代码相对应的描述。例如，
> ```c
> 	r = -E_NO_MEM;
>	panic("env_alloc: %e", r);
> ```
> 将因消息“`env_alloc`：内存不足“而中断。

下面是调用用户代码之前的代码调用图。确保您了解每个步骤的目的。
* `start (kern/entry.S)`
* `i386_init (kern/init.c)`
   * `cons_init`
   * `mem_init`
   * `env_init`
   * `trap_init` (still incomplete at this point)
   * `env_create`
   * `env_run`
     * `env_pop_tf`

完成后，您应该编译内核并在 QEMU 下运行它。如果一切顺利，您的系统应该进入用户空间并执行 `hello` 二进制文件，直到它使用 `int` 指令进行系统调用。到那时就会有麻烦，因为 JOS 还没有设置硬件来允许从用户空间到内核的转换。当CPU发现自己没有设置处理这个系统调用中断时，就会产生一个通用保护异常，发现自己处理不了这个通用保护异常，就产生一个`double fault`异常，发现自己也处理不了二重，最后就产生所谓的`triple fault`。通常，您随后会看到 CPU 重置和系统重启。虽然这对于遗留应用程序很重要（请参阅此[博客文章](http://blogs.msdn.com/larryosterman/archive/2005/02/08/369243.aspx)了解原因的解释），但它对内核开发来说是一种痛苦，因此使用 6.828 修补的 QEMU，您将看到寄存器转储和`triple fault`的信息。

我们将很快解决这个问题，但现在我们可以使用调试器来检查我们是否正在进入用户模式。使用 `make qemu-gdb` 并在 `env_pop_tf` 处设置 GDB 断点，这应该是内核在实际进入用户模式之前执行的最后一个函数。使用 `si` 单步执行此函数；处理器应该在 `iret` 指令之后进入用户模式。然后您应该在用户环境的可执行文件中看到第一条指令，即 `lib/entry.S` 中标签 `start` 处的 `cmpl` 指令。现在使用 `b *0x...` 在 `hello`文件的 `sys_cputs()`函数中的 `int $0x30` 处设置一个断点（请查看 `obj/user/hello.asm` 以获取用户空间该处的地址）。此 `int` 是向控制台显示字符的系统调用。如果您不能执行到 `int`，那么您的地址空间设置或程序加载代码有问题，在继续之前修复它。

## 处理中断和异常
此时，用户空间中的第一个 `int $0x30` 系统调用指令是死局：一旦处理器进入用户模式，就没有办法退出。您现在需要实现基本的异常和系统调用处理，以便内核可以从用户模式代码中恢复对处理器的控制（从用户模式转为内核模式）。您应该做的第一件事是彻底熟悉 x86 中断和异常机制。

> **练习3** 阅读《80386程序员手册》中的第九章 [异常和中断](https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm).

在本实验中，我们通常遵循 Intel 的中断、异常等术语。然而，异常、陷阱、中断、故障和中止等术语在不同架构或操作系统之间没有标准含义，并且在使用时经常不考虑它们在特定架构（如 x86）上的细微差别。当您在本实验室之外看到这些术语时，其含义可能会略有不同。

## 保护控制转移基础
异常和中断都是“受保护的控制转移”，这会导致处理器从用户模式切换到内核模式 (CPL=0)，而不会给用户模式代码任何干扰内核或其他环境运行的机会。在 Intel 的术语中，中断是一种受保护的控制转移，它由通常在处理器外部的异步事件引起，例如外部设备 I/O 活动的通知。相反，异常是由当前运行的代码引起的受保护的控制转移，例如由于被零除或无效的内存访问。

为了确保这些受保护的控制转移真正受到保护，处理器的中断/异常机制被设计成当中断或异常发生时当前运行的代码不能随意选择进入内核的位置或方式。相反，处理器确保只有在安全的条件下才能进入内核。在 x86 上，有两种机制共同提供这种保护：
1. 中断描述符表：处理器确保中断和异常只能导致内核在几个特定的​​、定义明确的入口点进入内核，这些入口点由内核本身决定，而不是由中断或异常发生时运行的代码决定的。x86 允许多达 256 个不同的中断或异常入口点进入内核，每个都有不同的中断向量（中断处理程序的入口地址）。向量是介于 0 和 255 之间的数字。中断的向量由中断源决定：不同的设备、错误条件和对内核的应用程序请求会生成具有不同向量的中断。 CPU 使用向量作为处理器中断描述符表 (IDT) 的索引，内核在内核专用内存中设置该表，与 GDT 非常相似。处理器从该表中的适当条目加载：
   - 指令指针 (EIP) 寄存器的值，指向指定用于处理该类型异常的内核代码（中断处理程序地址）。
   - 代码段 (CS) 寄存器中的值，包含异常处理程序运行的特权级别。 （在 JOS 中，所有异常都在内核模式下处理，权限级别为 0。）
2. 任务状态段：处理器需要一个地方来保存中断或异常发生之前的旧处理器状态，例如处理器调用异常处理程序之前的 EIP 和 CS 的原始值，以便异常处理程序稍后可以恢复旧状态并恢复被中断的状态从它停止的地方重新开始。但是这个旧处理器状态的保存区域必须被保护不受非特权用户模式代码的影响；否则错误或恶意的用户代码可能会危及内核。              
因此，当 x86 处理器发生中断或陷阱导致权限级别从用户模式改为内核模式时，它也会切换到内核内存中的堆栈。任务状态段 (TSS) 的结构指定了该堆栈所在的段选择器和地址。处理器（在这个新堆栈上）压入 SS、ESP、EFLAGS、CS、EIP 和一个可选的错误代码。然后它从中断描述符中加载 CS 和 EIP，并设置 ESP 和 SS 以引用新堆栈。                   
尽管 TSS 很大并且可能有多种用途，但 JOS 仅使用它来定义处理器在从用户模式转移到内核模式时应该切换到的内核堆栈。由于 JOS 中的“内核模式”在 x86 上是特权级别 0，因此处理器在进入内核模式时使用 TSS 的 `ESP0` 和 `SS0` 字段来定义内核堆栈。 JOS 不使用任何其他 TSS 字段。

## 中断和异常的类型
x86 处理器可以在内部生成的所有同步异常都使用 0 到 31 之间的中断向量，因此映射到 IDT 条目 0-31。例如，页面错误总是通过向量 14 引起异常。大于 31 的中断向量仅供软件中断使用，软件中断可以由 `int` 指令生成，或异步硬件中断，由外部设备在需要注意时引起。

在本节中，我们将扩展 JOS 以处理向量 0-31 中内部生成的 x86 异常。在下一节中，我们将使 JOS 处理软件中断向量 48 (0x30)，JOS（相当任意地）将其用作其系统调用中断向量。在实验 4 中，我们将扩展 JOS 以处理外部生成的硬件中断，例如时钟中断。

## 例子
假设处理器正在用户环境中执行代码并遇到一条试图除以零的除法指令（非法指令--异常）。
1. 处理器切换到由 TSS 的 `SS0` 和 `ESP0` 字段定义的堆栈，在 JOS 中，它们将分别保存值 `GD_KD` 和 `KSTACKTOP`。
2. 处理器从地址 `KSTACKTOP` 开始将异常参数压入内核堆栈:
   ```
                     +--------------------+ KSTACKTOP             
                     | 0x00000 | old SS   |     " - 4
                     |      old ESP       |     " - 8
                     |     old EFLAGS     |     " - 12
                     | 0x00000 | old CS   |     " - 16
                     |      old EIP       |     " - 20 <---- ESP 
                     +--------------------+             
   ```
3. 因为我们正在处理除法错误，它是 x86 上的中断向量 0，所以处理器读取 IDT 条目 `0` 并将 `CS:EIP` 设置为指向条目描述的处理程序函数。
4. 处理函数控制并处理异常，例如通过终止用户环境。

对于某些类型的 x86 异常，除了上面的“标准”五个字之外，处理器还会将另一个包含错误代码的字压入堆栈。页面错误异常，编号 `14`，是一个重要的例子。请参阅 80386 手册以确定处理器为哪些异常编号压入错误代码，以及在这种情况下错误代码的含义。当处理器推送错误代码时，从用户模式进入内核模式时，堆栈如下：
```
                     +--------------------+ KSTACKTOP             
                     | 0x00000 | old SS   |     " - 4
                     |      old ESP       |     " - 8
                     |     old EFLAGS     |     " - 12
                     | 0x00000 | old CS   |     " - 16
                     |      old EIP       |     " - 20
                     |     error code     |     " - 24 <---- ESP
                     +--------------------+             
```

## 嵌套异常和中断
处理器可以从内核模式和用户模式接受异常和中断。然而，只有当从用户模式进入内核时，x86 处理器才会在将其旧寄存器状态压入堆栈并通过 IDT 调用适当的异常处理程序之前自动切换堆栈。如果在中断或异常发生时处理器已经处于内核模式（`CS` 寄存器的低 2 位已经为零），则 CPU 只是将更多值压入同一个内核堆栈。这样，内核就可以优雅地处理由内核自身代码引起的嵌套异常。此功能是实现保护的重要工具，我们将在稍后的系统调用部分中看到。

*如果处理器已经处于内核模式并发生嵌套异常，则由于不需要切换堆栈* ，因此不会保存旧的 `SS` 或 `ESP` 寄存器。对于不推送错误代码的异常类型，内核堆栈因此在进入异常处理程序时看起来如下所示：
```
                     +--------------------+ <---- old ESP
                     |     old EFLAGS     |     " - 4
                     | 0x00000 | old CS   |     " - 8
                     |      old EIP       |     " - 12
                     +--------------------+             
```
对于推送错误代码的异常类型，处理器会像以前一样在旧 `EIP` 之后立即推送错误代码。

处理器的嵌套异常功能有一个重要警告。如果处理器在已经处于内核模式时发生异常，并且由于任何原因（例如堆栈空间不足）无法将其旧状态推送到内核堆栈，那么处理器将无法恢复，因此它只会自行重置。内核的设计应该避免这种情况发生。

## 设置IDT
现在开始在 JOS 中设置 IDT 和处理异常。将设置 IDT 来处理中断向量 0-31（处理器异常）。我们将在本实验的后面处理系统调用（48）中断，并在后面的实验中添加中断 32-47（设备 IRQ）。

头文件 `inc/trap.h` 和 `kern/trap.h` 包含您需要熟悉的与中断和异常相关的重要定义。文件 `kern/trap.h` 包含对内核严格私有的定义，而 `inc/trap.h` 包含对用户级程序和库也可能有用的定义。

注：0-31 范围内的部分异常是 Intel 定义为保留的。由于它们永远不会由处理器生成，因此您如何处理它们并不重要。做任何你认为最干净的事情。

您应该实现的总体控制流程如下所示：
```
      IDT                   trapentry.S         trap.c
   
+----------------+                        
|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)
|                |             // do stuff      {
|                |             call trap          // handle the exception/interrupt
|                |             // ...           }
+----------------+
|   &handler2    |--------> handler2:
|                |            // do stuff
|                |            call trap
|                |            // ...
+----------------+
       .
       .
       .
+----------------+
|   &handlerX    |--------> handlerX:
|                |             // do stuff
|                |             call trap
|                |             // ...
+----------------+
```
每个异常或中断都应该在 `trapentry.S` 中有自己的处理程序，并且 `trap_init()` 应该使用这些处理程序的地址初始化 IDT。每个处理程序都应该在堆栈上构建一个 `struct Trapframe`（请参阅 `inc/trap.h`）并使用指向 `Trapframe` 的指针调用 `trap()`（在 `trap.c` 中）。 `trap()` 然后处理异常/中断或分派到特定的处理函数。
> **练习4** 编辑 `trapentry.S` 和 `trap.c` 并实现上述功能。 `trapentry.S` 中的宏 `TRAPHANDLER` 和 `TRAPHANDLER_NOEC` 以及 `inc/trap.h` 中定义的 `T_*` 应该对您有帮助。--您需要在 `trapentry.S` 中为 `inc/trap.h` 中定义的每个陷阱添加一个入口点（使用这些宏），并且您必须提供 `TRAPHANDLER` 宏引用的 `_alltraps`。--您还需要修改 `trap_init()` 以初始化 `idt` 以指向 `trapentry.S` 中定义的每个入口点； `SETGATE` 宏在这里会有帮助。                
> 你的 `_alltraps` 应该：
> 1. 压入值使堆栈看起来像一个 `struct Trapframe`
> 2. 将 `GD_KD` 加载到 `%ds` 和 `%es`
> 3. `pushl %esp` 将指向 `Trapframe` 的指针作为参数传递给 `trap()`
> 4. `call trap`（`trap` 会返回吗？） 
>
> 考虑使用 `pushal` 指令；它非常适合 `struct Trapframe` 的布局。
> 
> 在进行任何系统调用之前，使用用户目录中导致异常的一些测试程序测试您的陷阱处理代码，例如 `user/divzero`。此时您应该能够在 `divzero`、`softint` 和 `badsegment` 测试中取得成功。

> *challenge* 挑战！在 `trapentry.S` 中的 `TRAPHANDLER` 列表和它们在 `trap.c` 中的安装之间，您现在可能有很多非常相似的代码。清理这个。修改`trapentry.S`中的宏，自动生成表格供`trap.c`使用。请注意，您可以使用指令 `.text` 和 `.data` 在汇编器中的代码和数据之间切换。

> **问题** 回答以下问题：
> 1. 为每个异常/中断设置单独的处理函数的目的是什么？ （即，如果所有异常/中断都传递给同一个处理程序，则无法提供当前实现中存在的哪些功能？）
> 2. 您是否必须做某些事情才能使 `user/softint` 程序正常运行？评分脚本期望它产生一般保护错误（陷阱 13），但 `softint` 的代码显示 `int $14`。为什么这会产生中断向量 13？如果内核实际上允许 `softint` 的 `int $14` 指令调用内核的页面错误处理程序（即中断向量 14），会发生什么情况？


# Part B:页面错误、断点异常、系统调用
现在内核具有基本的异常处理功能，您将对其进行优化，以提供依赖于异常处理的操作系统原语。
## 处理页面错误
页面错误异常，中断向量 14 (`T_PGFLT`)，是一个特别重要的异常，我们将在本实验和下一个实验中大量练习。当处理器发生页面错误时，它会把错误的线性（即虚拟）地址存储在特殊的处理器控制寄存器 `CR2` 中。在 `trap.c` 中，我们提供了一个特殊函数 `page_fault_handler()` ，用于处理页面错误异常。
> **练习5** 修改 `trap_dispatch()` 以将页面错误异常分派给 `page_fault_handler()`。完成后应该能够使用`make grade`通过 `faultread`、`faultreadkernel`、`faultwrite` 和 `faultwritekernel` 的测试。如果它们中的任何一个没有通过，找出原因并修复它们。请记住，您可以使用 `make run-x` 或 `make run-x-nox` 将 JOS 引导到特定的用户程序。例如，`make run-hello-nox` 运行 `hello` 用户程序。

在您实现系统调用时，您将进一步细化内核的页面错误处理。

## 断点异常
断点异常，中断向量 3 (`T_BRKPT`)，通常用于允许调试器通过用特殊的 1 字节 `int3` 软件中断指令临时替换相关程序指令来在程序代码中插入断点。**在 JOS 中，我们会稍微滥用这个异常，将其变成一个原始的伪系统调用，任何用户环境都可以使用它来调用 JOS 内核监视器**。如果我们将 JOS 内核监视器视为原始调试器，那么这种用法实际上有些合适。例如，`lib/panic.c` 中 `panic()` 的用户模式实现在显示其panic消息后执行 `int3`。

> **练习6** 修改 `trap_dispatch()` 使断点异常调用内核监视器。修改后应该可以通过 `make grade` 的`breakpoint`测试。

> 问题：      
> 3. 断点测试用例将生成断点异常或一般保护错误，具体取决于您在 IDT 中初始化断点条目的方式（即，您从 `trap_init` 调用 `SETGATE`）。为什么？您需要如何设置它才能使断点异常按上面指定的方式工作，以及什么不正确的设置会导致它触发一般保护错误？         
> 4. 您认为这些机制的意义何在，特别是考虑到 `user/softint` 测试程序的作用？


## 系统调用
用户进程通过调用系统调用请求内核为他们做事。当用户进程调用系统调用时，处理器进入内核模式，处理器和内核协同保存用户进程的状态，内核执行相应的代码以执行系统调用，然后恢复用户进程。用户进程如何引起内核的注意以及它如何指定要执行哪个调用的具体细节因系统而异。

在 JOS 内核中，我们将使用 `int` 指令，它会导致处理器中断。特别是，我们将使用 `int $0x30` 作为系统调用中断。我们已经为您定义了常量 `T_SYSCALL` 为 48 (0x30)。您将必须设置中断描述符以允许用户进程引起该中断。请注意，中断 `0x30` 不能由硬件生成，因此不存在允许用户代码生成它而导致的歧义。

应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中四处搜寻。系统调用号将放在 `%eax` 中，参数（最多五个）将分别放在 `%edx、%ecx、%ebx、%edi 和 %esi` 中。内核在 `%eax` 中传回返回值。在 `lib/syscall.c` 的 `syscall()` 中，已经为您编写了调用系统调用的汇编代码。您应该通读它并确保您了解发生的事情。

> **练习7** 在内核中为中断向量 `T_SYSCALL` 添加一个处理程序。您将不得不编辑 `kern/trapentry.S` 和 `kern/trap.c` 的 `trap_init()`。      
> 您还需要更改 `trap_dispatch()` 以通过使用适当的参数调用 `syscall()`（在 `kern/syscall.c` 中定义）来处理系统调用中断，然后安排返回值在 `%eax` 中传递回用户进程。         
> 最后，您需要在 `kern/syscall.c` 中实现 `syscall()`。如果系统调用号无效，请确保 `syscall()` 返回 `-E_INVAL`。您应该阅读并理解 `lib/syscall.c`（尤其是内联汇编例程）以确认您对系统调用接口的理解。通过为每个调用调用相应的内核函数来处理 `inc/syscall.h` 中列出的所有系统调用。
>
>在你的内核下运行 `user/hello` 程序（`make run-hello`）。它应该在控制台上打印“`hello, world`”，然后在用户模式下导致页面错误。如果这没有发生，则可能意味着您的系统调用处理程序不太正确。您现在也应该能够获得 `make grade` 以在 `testbss` 测试中取得成功。

## 用户模式启动
用户程序开始在 `lib/entry.S` 的头部运行。经过一些设置后，此代码调用 `lib/libmain.c` 中的 `libmain()`。您应该修改 `libmain()` 以初始化全局指针 `thisenv` 以指向 `envs[]` 数组中此环境的 `struct Env`。 （请注意，`lib/entry.S` 已经定义了 `envs` 以指向您在 Part A 中设置的 `UENVS` 映射。）提示：查看 `inc/env.h` 并使用 `sys_getenvid`。

`libmain()` 然后调用 `umain`，就 `hello` 程序而言，它位于 `user/hello.c` 中。请注意，在打印“`hello, world`”之后，它会尝试访问`thisenv->env_id`。这就是它较早出现故障的原因。现在您已经正确初始化了 `thisenv`，它应该不会出错。如果它仍然出错，您可能还没有映射用户可读的 `UENVS` 区域（回到 `pmap.c`,这是我们第一次实际使用 `UENVS` 区域）。

> **练习8** 将所需的代码添加到用户库中，然后引导您的内核。您应该看到 `user/hello` 打印“`hello, world`”，然后打印“`i am environment 00001000`”。 `user/hello` 然后通过调用 `sys_env_destroy()` 尝试“退出”（参见 `lib/libmain.c` 和 `lib/exit.c`）。由于内核目前只支持一个用户环境，它应该报告它已经破坏了唯一的环境，然后进入内核监视器。您应该能够通过 `make grade` 中的 `hello` 测试中取得成功。

## 页面错误和内存保护
内存保护是操作系统的一项重要功能，可确保一个程序中的错误不会破坏其他程序或破坏操作系统本身。

操作系统通常依靠硬件支持来实现内存保护。操作系统让硬件知道哪些虚拟地址有效，哪些无效。当一个程序试图访问一个无效地址或它没有权限的地址时，处理器会在导致错误的指令处停止程序，然后将有关尝试操作的信息陷入内核（中断）。如果故障是可修复的，内核可以修复它并让程序继续运行。如果错误无法修复，则程序无法继续，因为它永远无法执行完会导致错误的指令。

作为可修复故障的示例，请考虑自动扩展堆栈。在许多系统中，内核最初分配单个堆栈页面，然后如果程序在访问堆栈下方的页面时出错（堆栈空间不足），内核将自动分配这些页面并让程序继续（扩充堆栈空间）。通过这样做，内核只分配程序所需的堆栈内存，但程序可以在拥有任意大堆栈的错觉下工作。

系统调用为内存保护提出了一个有趣的问题。大多数系统调用接口让用户程序将指针传递给内核。这些指针指向要读取或写入的用户缓冲区。然后内核在执行系统调用时解引用这些指针。这有两个问题：
1. 内核中的页面错误可能比用户程序中的页面错误严重得多。如果内核在操作自己的数据结构时发生页面错误，那就是内核错误，错误处理程序应该使内核（以及整个系统）中断（panic）。但是当内核解引用用户程序给它的指针时，它需要一种方法来记住这些解引用导致的任何页面错误实际上是用户程序导致的。
2. 内核通常比用户程序拥有更多的内存权限。用户程序可能会传递一个指向系统调用的指针，该指针指向内核可以读取或写入但程序不能读取或写入的内存。内核必须小心，不要被用户程序欺骗而解引用这样的指针，因为这可能会泄露私有信息或破坏内核的完整性。

由于这两个原因，内核在处理用户程序提供的指针时必须格外小心。

您现在将使用一种机制来解决这两个问题，该机制会仔细检查从用户空间传递到内核的所有指针。当程序向内核传递一个指针时，内核将检查地址是否在地址空间的用户部分，以及页表是否允许内存操作。

因此，内核永远不会因为解引用用户提供的指针而出现页面错误。如果内核出现页面错误，它应该崩溃并终止。
> **练习9** 如果在内核模式下发生页面错误，更改 `kern/trap.c` 使内核panic。
>
>提示：要判断错误发生在用户模式还是内核模式，请查看 `tf_cs` 的低位。
>
>阅读 `kern/pmap.c` 中的 `user_mem_assert` 并在同一个文件中实现 `user_mem_check`。
>
>更改 `kern/syscall.c` 以完整检查系统调用的参数。
>
>启动你的内核，运行 `user/buggyhello`。环境应该被破坏，内核不应该panic。你应该看到：
>```	
>	[00001000] user_mem_check assertion failure for va 00000001
>	[00001000] free env 00001000
>	Destroyed the only environment - nothing more to do!
>```
> 最后，更改 `kern/kdebug.c` 中的 `debuginfo_eip` 以在 `usd`、`stabs` 和 `stabstr` 上调用 `user_mem_check`。如果您现在运行 `user/breakpoint`，您应该能够从内核监视器运行`backtrace`命令，并在内核因页面错误而崩溃之前看到回溯遍历到 `lib/libmain.c`。是什么导致了这个页面错误？您不需要修复它，但您应该了解它发生的原因。

请注意，您刚刚实现的相同机制也适用于恶意用户应用程序（例如 `user/evilhello`）。

> **练习10** 启动你的内核，运行 `user/evilhello`。环境应该被破坏，内核不应该panic。你应该看到：
> ```
>	[00000000] new env 00001000
>	...
>	[00001000] user_mem_check assertion failure for va f010000c
>	[00001000] free env 00001000
>```

