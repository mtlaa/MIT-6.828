# Lab 4：抢占式多任务处理
# 引言
在本实验中，您将在多个同时活动的用户模式环境中实现抢占式多任务处理。

在 A 部分，您将为 JOS 添加多处理器支持，实现循环调度，并添加基本的环境管理系统调用（创建和销毁环境以及分配/映射内存的调用）。

在 B 部分，您将实现类 Unix 的 `fork()`，它允许用户模式环境创建其自身的副本。

最后，在 C 部分中，您将添加对进程间通信 (IPC) 的支持，允许不同的用户模式环境显式地相互通信和同步。您还将添加对硬件时钟中断和抢占的支持。

## 开始
把`lab3`分支合并到`origin/lab4`分支，其中包含以下几个新的源文件：
- `kern/cpu.h` 多处理器支持的内核私有定义
- `kern/mpconfig.c`读取多处理器配置的代码
- `kern/lapic.c`驱动每个处理器中本地 APIC 单元的内核代码
- `kern/mpentry.S` 非引导 CPU 的汇编语言入口代码
- `kern/spinlock.h` 自旋锁的内核私有定义，包括大内核锁
- `kern/spinlock.c`实现自旋锁的内核代码
- `kern/sched.c` 您将要实现的调度程序的代码框架

# Part A:多处理器支持和协作式多任务处理
在本实验的第一部分，您将首先扩展 JOS 以在多处理器系统上运行，然后实现一些新的 JOS 内核系统调用以允许用户级环境创建额外的新环境。您还将实施协作循环调度，允许内核在当前环境自愿放弃 CPU（或退出）时从一个环境切换到另一个环境。后面在Part C，您将实现抢占式调度，它允许内核在经过特定时间后从环境中重新控制 CPU，即使环境不合作也是如此。

## 多处理器支持
我们将使 JOS 支持“对称多处理”（SMP），这是一种多处理器模型，其中所有 CPU 对系统资源（如内存和 I/O 总线）具有同等的访问权限。虽然所有 CPU 在 SMP 中的功能都相同，但在引导过程中它们可以分为两种类型：`引导处理器 (BSP)` 负责初始化系统和引导操作系统；只有在操作系统启动并运行后，`应用处理器 (AP)` 才会被 BSP 激活。哪个处理器是BSP是由硬件和BIOS决定的。到目前为止，所有现有的 JOS 代码都已在 BSP 上运行。

在 SMP 系统中，每个 CPU 都有一个伴随的本地 APIC (`LAPIC`) 单元。LAPIC 单元负责在整个系统中传递中断。LAPIC 还为其连接的 CPU 提供唯一标识符。在本实验中，我们使用 LAPIC 单元的以下基本功能（在`kern/lapic.c` 中）：
- 读取 LAPIC 标识符 (APIC ID) 以了解我们的代码当前运行在哪个 CPU 上（参见`cpunum()`）。
- 将`STARTUP`处理器间中断 (IPI) 从 BSP 发送到 AP 以启动其他 CPU（参见 `lapic_startap()`）。
- 在 Part C，我们对 LAPIC 的内置定时器进行编程以触发时钟中断以支持抢占式多任务处理（请参阅 `lapic_init()`）。

处理器使用 内存映射I/O (MMIO) 访问其 LAPIC。在 MMIO 中，一部分物理内存被硬连线到某些 I/O 设备的寄存器，因此通常用于访问内存的 load/store 指令可用于访问设备寄存器。您已经在物理地址 `0xA0000`处看到一个 IO hole（我们使用它来写入 VGA 显示缓冲区）。LAPIC 位于一个从物理地址 `0xFE000000`（比 4GB 少 32MB）开始的 hole 中，因此我们在 `KERNBASE` 使用我们通常的直接映射访问它太高了。JOS 虚拟内存映射在`MMIOBASE`留下 4MB 的空隙所以我们有一个地方可以像这样映射设备。由于后面的实验引入了更多的 MMIO 区域，您将编写一个简单的函数来从该区域分配空间并将设备内存映射到它。

> **Exercise 1** 在 `kern/pmap.c` 中实现 `mmio_map_region`。要了解它是如何使用的，请查看 `kern/lapic.c` 中 `lapic_init` 的开头。在运行 `mmio_map_region` 的测试之前，您还必须完成下一个练习。

### 应用处理器引导程序
在启动 AP 之前，BSP 应该首先收集有关多处理器系统的信息，例如 CPU 总数、它们的 APIC ID 和 LAPIC 单元的 MMIO 地址。 `kern/mpconfig.c` 中的 `mp_init()` 函数通过读取驻留在 BIOS 内存区域中的 MP 配置表来检索此信息。

`boot_aps()`函数（在`kern/init.c`中）驱动 AP 引导过程。AP 在实模式下启动，很像引导加载程序在`boot/boot.S`中启动的方式，因此`boot_aps()` 将 AP 入口代码 ( `kern/mpentry.S` ) 复制到在实模式下可寻址的内存位置。与引导加载程序不同，我们可以控制 AP 从何处开始执行代码；我们将入口代码复制到`0x7000` ( `MPENTRY_PADDR`)，但是 640KB 以下的任何未使用的、页面对齐的物理地址都可以使用。

之后，`boot_aps()` 通过向相应 AP 的 LAPIC 单元发送 `STARTUP` IPI 以及 AP 应开始运行其入口代码（在我们的例子中为 `MPENTRY_PADDR`）的初始 `CS:IP` 地址，一个接一个地激活 AP。 `kern/mpentry.S` 中的入口代码与 `boot/boot.S` 中的入口代码非常相似。经过一些简单的设置后，它将 AP 置于启用分页的保护模式，然后调用 C 设置例程 `mp_main()`（也在 `kern/init.c` 中）。 `boot_aps()` 等待 AP 在其 `struct CpuInfo` 的 `cpu_status` 字段为 `CPU_STARTED` 标志，然后继续唤醒下一个。

> **Exercise 2** 阅读 `kern/init.c` 中的 `boot_aps()` 和 `mp_main()`，以及 `kern/mpentry.S` 中的汇编代码。确保您了解 AP 引导期间的控制流传输。然后修改 `kern/pmap.c` 中 `page_init()` 的实现，避免将 `MPENTRY_PADDR` 处的页面添加到空闲列表中，这样我们就可以安全地在该物理地址复制和运行 AP 引导程序代码。您的代码应该通过更新的 `check_page_free_list()` 测试（但可能无法通过更新的 `check_kern_pgdir()` 测试，我们将很快修复）。

> **Question**
> 1. 将 `kern/mpentry.S` 与 `boot/boot.S` 比较。请记住，`kern/mpentry.S` 被编译并链接到 `KERNBASE` 之上，就像内核中的其他所有内容一样，宏 `MPBOOTPHYS` 的目的是什么？为什么在 `kern/mpentry.S` 中有必要，而在 `boot/boot.S` 中没有？换句话说，如果在 `kern/mpentry.S` 中省略它会出什么问题？     
>提示：回想一下我们在 lab 1 中讨论过的链接地址和加载地址之间的区别。

### 每个CPU的状态和初始化
在编写多处理器操作系统时，区分每个处理器私有的 CPU 状态和整个系统共享的全局状态很重要。 `kern/cpu.h` 定义了每个 CPU 的大部分状态，包括存储每个 CPU 变量的 `struct CpuInfo`。 `cpunum()` 总是返回调用它的 CPU 的 ID，它可以用作 `cpus` 等数组的索引。或者，宏 `thiscpu` 是当前 CPU 的 `struct CpuInfo` 的指针。

以下是您应该注意的每个 CPU 状态：
- **每 CPU 的内核堆栈**        
  因为多个 CPU 可以同时陷入内核，所以我们需要为每个处理器提供一个单独的内核堆栈，以防止它们相互干扰执行。数组 `percpu_kstacks[NCPU][KSTKSIZE]` 为 NCPU 的内核堆栈保留空间。        
  在实验 2 中，您将`bootstack`所指的物理内存映射为位于`KSTACKTOP`正下方的BSP内核堆栈。同样，在本实验中，您将把每个 CPU 的内核堆栈映射到这个区域，保护页充当它们之间的缓冲区。 CPU 0 的堆栈仍然会从 `KSTACKTOP` 向下增长； CPU 1 的堆栈将从 CPU 0 堆栈底部下方的 `KSTKGAP` 字节开始，依此类推。 `inc/memlayout.h` 显示映射布局。
- **每 CPU TSS(任务状态段) 和 TSS 描述符**                 
  还需要每个 CPU 任务状态段 (TSS) 以指定每个 CPU 的内核堆栈所在的位置。 CPU i 的 TSS 存储在 `cpus[i].cpu_ts` 中，相应的 TSS 描述符定义在 GDT 条目 `gdt[(GD_TSS0 >> 3) + i]` 中。 `kern/trap.c` 中定义的全局 `ts` 变量将不再有用。
- **每 CPU 当前环境指针**             
  由于每个 CPU 可以同时运行不同的用户进程，我们重新定义了符号 `curenv` 来指代 `cpus[cpunum()].cpu_env`（或 `thiscpu->cpu_env`），它指向当前 CPU 上当前执行的环境。
- **每 CPU 系统寄存器**                
  所有寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，如`lcr3()`、`ltr()`、`lgdt()`、`lidt()`等，必须在每个CPU上执行一次。为此定义了函数 `env_init_percpu()` 和 `trap_init_percpu()`。                
  除此之外，如果您在您的解决方案中添加了任何额外的每个 CPU 状态或执行了任何额外的特定于 CPU 的初始化（例如，在 CPU 寄存器中设置新位）以挑战早期实验室中的问题，请务必复制它们在每个 CPU 上！

> **Exercise 3** 修改 `mem_init_mp()`（在 `kern/pmap.c` 中）以映射从 `KSTACKTOP` 开始的每个 CPU 堆栈，如 `inc/memlayout.h` 中所示。每个堆栈的大小是 `KSTKSIZE` 字节加上未映射保护页的 `KSTKGAP` 字节。您的代码应该通过 `check_kern_pgdir()` 中的新检查。

> **Exercise 4** `trap_init_percpu()` (`kern/trap.c`) 中的代码为 BSP 初始化 TSS 和 TSS 描述符。它在实验 3 中有效，但在其他 CPU 上运行时不正确。更改代码，使其可以在所有 CPU 上工作。 （注意：您的新代码不应再使用全局 `ts` 变量。） 

完成上述练习后，使用 `make qemu CPUS=4`（或 `make qemu-nox CPUS=4`）在具有 4 个 CPU 的 QEMU 中运行 JOS，您应该看到如下输出：
```
...
Physical memory: 66556K available, base = 640K, extended = 65532K
check_page_alloc() succeeded!
check_page() succeeded!
check_kern_pgdir() succeeded!
check_page_installed_pgdir() succeeded!
SMP: CPU 0 found 4 CPU(s)
enabled interrupts: 1 2
SMP: CPU 1 starting
SMP: CPU 2 starting
SMP: CPU 3 starting
```

### 锁
我们当前的代码在 `mp_main()` 中初始化 AP 后就会“自旋”（spin）。在让 AP 更进一步之前，我们首先需要解决多个 CPU 同时运行内核代码时的竞争条件。实现这一点的最简单方法是使用大内核锁。大内核锁是一个单一的全局锁，每当环境进入内核模式时就会持有，并在环境返回用户模式时释放。在此模型中，用户模式下的环境可以在任何可用的 CPU 上并发运行，但内核模式下只能运行一个环境；任何其他试图进入内核模式的环境都将被迫等待。

`kern/spinlock.h` 声明了大内核锁，即`kernel_lock`。它还提供了 `lock_kernel()` 和 `unlock_kernel()` 以获取和释放锁。您应该在四个位置应用大内核锁：
- 在 `i386_init()` 中，在 BSP 唤醒其他 CPU 之前获取锁。
- 在`mp_main()`中，初始化AP后获取锁，然后调用`sched_yield()`在这个AP上开始运行环境。
- 在 `trap()` 中，从用户模式陷入时获取锁。要确定trap是发生在用户模式还是内核模式，请检查 `tf_cs` 的低位。
- 在 `env_run()` 中，在切换到用户模式之前立即释放锁。不要太早或太晚这样做，否则您将遇到竞争或死锁。

> **Exercise 5** 如上所述，通过在适当的位置调用 `lock_kernel()` 和 `unlock_kernel()` 来应用大内核锁。

现在还不能检查练习5是否正确，在下一个练习中实现调度程序后才可以检查。

> **Question 2** 似乎使用大内核锁可以保证一次只有一个 CPU 可以运行内核代码。为什么我们仍然需要为每个 CPU 提供单独的内核堆栈？描述一个使用共享内核栈会出错的场景，即使有大内核锁的保护。

## 循环调度
您在本实验中的下一个任务是更改 JOS 内核，以便它可以以“循环”方式在多个环境之间切换。 JOS 中的循环调度工作如下：
- `kern/sched.c` 中的函数 `sched_yield()` 负责选择一个新的环境来运行。它以循环方式顺序搜索 `envs[]` 数组，每次搜索起始位置从先前运行的环境之后开始（如果没有先前运行的环境，则从数组的开头开始），选择它找到的第一个状态为 `ENV_RUNNABLE` 的环境（请参阅`inc/env.h`)，并调用 `env_run()` 跳转到该环境。
- `sched_yield()` 绝不能同时在两个 CPU 上运行相同的环境。它可以判断环境当前正在某个 CPU（可能是当前 CPU）上运行，因为该环境的状态将为 `ENV_RUNNING`。
- 我们为您实现了一个新的系统调用，`sys_yield()`，用户环境可以调用它来调用内核的 `sched_yield()` 函数，从而主动放弃 CPU ，让给其他环境。

> **Exercise 6** 如上所述，在 `sched_yield()` 中实现循环调度。不要忘记修改 `syscall()` 以分派 `sys_yield()`系统调用。                 
> 确保在 `mp_main` 中调用 `sched_yield()`。                           
> 修改 `kern/init.c` 以创建三个（或更多！）运行程序 `user/yield.c` 的环境。                   
> 运行 `make qemu`。在终止之前，您应该看到环境在彼此之间来回切换五次，如下所示。                  
> 也可以指定 CPU 数量进行测试：`make qemu CPUS=2`。                 
> ```
>...
>Hello, I am environment 00001000.
>Hello, I am environment 00001001.
>Hello, I am environment 00001002.
>Back in environment 00001000, iteration 0.
>Back in environment 00001001, iteration 0.
>Back in environment 00001002, iteration 0.
>Back in environment 00001000, iteration 1.
>Back in environment 00001001, iteration 1.
>Back in environment 00001002, iteration 1.
>...
>```
>`yield.c` 程序退出后，系统中将没有可运行的环境，调度程序应该调用 JOS 内核监视器。如果上述任何一种情况都没有发生，请在继续之前修复您的代码。

> **Question**            
> 3. 在您的 `env_run()` 实现中，您应该调用 `lcr3()`。在调用 `lcr3()` 之前和之后，您的代码引用（至少应该引用）变量 `e`，即 `env_run` 的参数。加载 `%cr3` 寄存器后，MMU 使用的寻址上下文会立即更改。但是虚拟地址（即 `e`）相对于给定的地址上下文具有——地址上下文指定虚拟地址映射到的物理地址。为什么在寻址切换之前和之后都可以解引用指针 `e`？                
> 4. 每当内核从一个环境切换到另一个环境时，它必须确保保存旧环境的寄存器，以便以后可以正确恢复它们。为什么？这发生在哪里？

## 环境创建的系统调用
虽然你的内核现在可以在多个用户级环境之间运行和切换，但它仍然仅限于内核最初设置的运行环境。您现在将实现必要的 JOS 系统调用，以允许用户环境创建和启动其他新用户环境。

Unix 提供 `fork()` 系统调用作为其进程创建原语。 Unix `fork()` 复制调用进程（父进程）的整个地址空间来创建一个新进程（子进程）。从用户空间观察到的两个对象之间的唯一区别是它们的进程 ID 和父进程 ID（由 `getpid` 和 `getppid` 返回）。在父进程中，`fork()` 返回子进程的 ID，而在子进程中，`fork()` 返回 0。默认情况下，每个进程都有自己的私有地址空间，两个进程对内存的修改对另一个进程是不可见的。

您将提供一组不同的、更原始的 JOS 系统调用来创建新的用户模式环境。通过这些系统调用，除了其他类型的环境创建之外，您还可以完全在用户空间中实现类似 Unix 的 `fork()`。您将为 JOS 编写的新系统调用如下：
- `sys_exofork`           
  这个系统调用创建了一个几乎是空白的新环境：在其地址空间的用户部分没有任何映射，并且它不可运行。在 `sys_exofork` 调用时，新环境将具有与父环境相同的注册状态。在父环境中，`sys_exofork` 将返回新创建环境的 `envid_t`（如果环境分配失败，则返回负错误代码）。然而，在子环境中，它将返回 0。（因为子环境开始时被标记为不可运行，所以 `sys_exofork` 实际上不会在子环境中返回，直到父环境标记子环境可运行后才允许这样做）
- `sys_env_set_status`               
  将指定环境的状态设置为 `ENV_RUNNABLE` 或 `ENV_NOT_RUNNABLE`。一旦其地址空间和寄存器状态已完全初始化,该系统调用通常用于标记新环境准备好运行。
- `sys_page_alloc`           
  分配一页物理内存并将其映射到给定环境地址空间中的给定虚拟地址。
- `sys_page_map`         
  将页面映射（不是页面的内容！）从一个环境的地址空间复制到另一个环境，保留内存共享安排，以便新旧映射都引用物理内存的同一页。(也就是让两个环境共享同一个物理页面)
- `sys_page_unmap`         
  取消映射到给定环境中给定虚拟地址的页面。

对于上面所有接受环境 ID 的系统调用，JOS 内核支持值 0 表示“当前环境”的约定。这个约定由 `kern/env.c` 中的 `envid2env()` 实现。

我们在测试程序 `user/dumbfork.c` 中提供了一个非常原始的类 Unix `fork()` 实现。该测试程序使用上述系统调用来创建和运行具有其自身地址空间副本的子环境。两个环境然后像上一个练习一样使用 `sys_yield` 来回切换。父级在 10 次迭代后退出，而子级在 20 次迭代后退出。

> **Exercise 7** 在 `kern/syscall.c` 中实现上面描述的系统调用，并确保 `syscall()` 调用它们。您将需要使用 `kern/pmap.c` 和 `kern/env.c` 中的各种函数，尤其是 `envid2env()`。现在，无论何时调用 `envid2env()`，在 `checkperm` 参数中传递 1。确保检查任何无效的系统调用参数，在这种情况下返回 `-E_INVAL`。使用 `user/dumbfork` 测试你的 JOS 内核并确保它在继续之前正常工作。

这就完成了实验的 A 部分；确保它在运行 `make grade` 时通过了所有 A 部分测试。如果您试图找出特定测试用例失败的原因，请运行 `./grade-lab4 -v`，它将向您显示内核构建的输出和 QEMU 为每个测试运行，直到测试失败。当测试失败时，脚本将停止，然后您可以检查 `jos.out` 以查看内核实际打印的内容。

# Part B:Copy-on-write Fork (写时复制fork)
如前所述，Unix 提供 `fork()` 系统调用作为其主要的进程创建原语。 `fork()` 系统调用复制调用进程（父进程）的地址空间以创建新进程（子进程）。

xv6 Unix 通过将所有数据从父页面复制到分配给子页面的新页面来实现 `fork()`。这基本上与 `dumbfork()` 采用的方法相同。将父地址空间复制到子地址空间是 `fork()` 操作中最耗时的部分。

然而，在调用 `fork()` 之后，经常会立即调用子进程中的 `exec()` ，这会用一个新程序替换子进程的内存。这就是 shell 通常所做的。在这种情况下，复制父进程地址空间的时间大部分被浪费了，因为子进程在调用 `exec()` 之前将使用很少的内存。

出于这个原因，后来的 Unix 版本利用虚拟内存硬件允许父进程和子进程共享映射到各自地址空间的内存，直到其中一个进程实际修改它。这种技术称为写时复制（Copy-on-write）。为此，在 `fork()` 上，内核会将地址空间映射从父进程复制到子进程而不是复制页面的内容，同时将现在共享的页面标记为只读。当两个进程之一尝试写入这些共享页面之一时，该进程会出现页面错误。此时，Unix 内核意识到该页面实际上是一个“虚拟”或“写时复制”副本，因此它为故障进程制作了一个新的、私有的、可写的页面副本。这样，各个页面的内容在实际写入之前不会被实际复制。这种优化使得子进程中的 `fork()` 后跟 `exec()` 成本更低：子进程可能只需要在调用 `exec()` 之前复制一页（其堆栈的当前页）。

在本实验的下一部分中，您将实现一个“适当的”类 Unix `fork()`，它具有写时复制功能，作为用户空间库例程。在用户空间中实现 `fork()` 和写时复制支持的好处是内核保持简单得多，因此更有可能是正确的。它还允许各个用户模式程序为 `fork()` 定义自己的语义。想要稍微不同实现的程序（例如，像 `dumbfork()` 这样昂贵的始终复制版本，或者父子之后实际上共享内存的版本）可以轻松提供自己的实现。

**简单来说，非写时复制fork直接把父进程的页面全部拷贝一份给子进程。写时复制fork技术只把父进程的内存映射复制给子进程，它们共享物理页面，只有当一方想要写其中的某个页面时才复制那个物理页面，这样父子进程也可以互不干扰。**

## 用户级缺页处理
用户级写时复制 `fork()` 需要了解写保护页面上的页面错误，因此这是您首先要实现的。写时复制只是用户级页面错误处理的方法之一。

设置一个地址空间是很常见的，这样页面错误就可以指示何时需要采取一些行动。例如，大多数 Unix 内核最初只映射新进程堆栈区域中的单个页面，然后随着进程的堆栈消耗增加并导致尚未映射的堆栈地址出现页面错误，“按需”分配和映射其他堆栈页面。典型的 Unix 内核必须跟踪在进程空间的每个区域发生页面错误时要采取的操作。例如，堆栈区域中的故障通常会分配和映射新的物理内存页面。程序 BSS 区域中的错误通常会分配一个新页面，用零填充它，然后映射它。在具有按需分页可执行文件的系统中，文本区域中的错误将从磁盘读取二进制文件的相应页面，然后将其映射。

上述是内核要跟踪的信息。您将决定如何处理用户空间中的每个页面错误，而不是采用传统的 Unix 方法，用户空间的页面错误破坏性较小。这种设计的好处是程序在定义其内存区域时具有极大的灵活性；稍后您将使用用户级页面错误处理来映射和访问基于磁盘的文件系统上的文件。

### 设置缺页处理程序
为了处理自己的页面错误，用户环境需要向 JOS 内核注册一个页面错误处理程序入口点。用户环境通过新的 `sys_env_set_pgfault_upcall` 系统调用注册其页面错误入口点。我们在 `Env` 结构中添加了一个新成员 `env_pgfault_upcall` 来记录这些信息。

> **Exercise 8** 实现 `sys_env_set_pgfault_upcall` 系统调用。在查找目标环境的环境 ID 时一定要启用权限检查，因为这是一个“危险”的系统调用。

### 用户环境中的正常和异常堆栈
在正常执行期间，JOS 中的用户环境将在*正常*用户堆栈上运行：它的 `ESP` 寄存器(存放栈顶指针)开始指向 `USTACKTOP`，它压入的堆栈数据位于 `USTACKTOP-PGSIZE` 和 `USTACKTOP-1` 之间的页面。然而，当在用户模式下发生页面错误时，内核将重新启动用户环境，在不同的堆栈（即用户*异常*堆栈）上运行指定的用户级页面错误处理程序。从本质上讲，我们将让 JOS 内核代表用户环境实现自动“堆栈切换”，就像 x86 处理器在从用户模式转移到内核模式时已经代表 JOS 实现堆栈切换一样！

JOS 用户异常堆栈也是一页大小，其顶部定义为虚拟地址 `UXSTACKTOP`，因此用户异常堆栈的有效字节从 `UXSTACKTOP-PGSIZE` 到 `UXSTACKTOP-1`（含）。在这个异常堆栈上运行时，用户级页面错误处理程序可以使用 JOS 的常规系统调用来映射新页面或调整映射，以修复最初导致页面错误的任何问题。然后用户级页面错误处理程序通过汇编语言存根返回到原始堆栈上的错误代码处继续执行。

每个支持用户级页面错误处理的用户环境都需要为自己的异常堆栈分配内存，使用 A 部分介绍的 `sys_page_alloc()` 系统调用。

### 调用用户页面错误处理程序
您现在需要更改 `kern/trap.c` 中的页面错误处理代码，以处理来自用户模式的页面错误，如下所示。我们将故障发生时用户环境的状态称为`trap-time`状态。

如果没有注册页面错误处理程序，JOS 内核会像以前一样用消息销毁用户环境。如果注册了页面错误处理程序，内核在异常堆栈上设置一个trap frame，看起来像来自 `inc/trap.h` 的 `struct UTrapframe`：
```
                    <-- UXSTACKTOP
trap-time esp
trap-time eflags
trap-time eip
trap-time eax       start of struct PushRegs
trap-time ecx
trap-time edx
trap-time ebx
trap-time esp
trap-time ebp
trap-time esi
trap-time edi       end of struct PushRegs
tf_err (error code)
fault_va            <-- %esp when handler is run
```
内核然后安排用户环境恢复执行，页面错误处理程序在具有该堆栈帧的异常堆栈上运行；你必须弄清楚如何做到这一点。 `fault_va` 是导致页面错误的虚拟地址。

如果在异常发生时用户环境已经在用户异常堆栈上运行，那么页面错误处理程序本身就出错了。在这种情况下，您应该在当前 `tf->tf_esp` 下而不是 `UXSTACKTOP` 开始新的堆栈帧。您应该首先压入一个空的 32 位字，然后是一个`struct UTrapframe`。

要测试 `tf->tf_esp` 是否已经在用户异常堆栈上，请检查它是否在 `UXSTACKTOP-PGSIZE` 和 `UXSTACKTOP-1` 之间的范围内。

> **Exercise 9** 在 `kern/trap.c` 中实现 `page_fault_handler` 中的代码，以将页面错误分派给用户模式处理程序。写入异常堆栈时一定要采取适当的预防措施。 （如果用户环境用完异常堆栈上的空间会怎样？）

### 用户模式页面错误入口点
接下来，您需要实现汇编例程，该例程将负责调用 C语言 页面错误处理程序并在原始错误指令处恢复执行。这个汇编例程是使用 `sys_env_set_pgfault_upcall()` 向内核注册的处理程序。

> **Exercise 10** 在 `lib/pfentry.S` 中实现 `_pgfault_upcall` 例程。有趣的部分是返回到导致页面错误的用户代码中的原始点。您将直接返回那里，而无需通过内核返回。困难的部分是同时切换堆栈和重新加载 `EIP`。

最后，您需要实现用户级页面错误处理机制的 C语言 用户端程序。

> **Exercise 11** 完成 `lib/pgfault.c` 中的 `set_pgfault_handler()`。

### 测试
运行 `user/faultread` (`make run-faultread`)。你应该看到：
```bash
...
[00000000] new env 00001000
[00001000] user fault va 00000000 ip 0080003a
TRAP frame ...
[00001000] free env 00001000
```
运行 `user/faultdie`。你应该看到：
```bash
...
[00000000] new env 00001000
i faulted at va deadbeef, err 6
[00001000] exiting gracefully
[00001000] free env 00001000
```
运行 `user/faultalloc`。你应该看到：
```bash
...
[00000000] new env 00001000
fault deadbeef
this string was faulted in at deadbeef
fault cafebffe
fault cafec000
this string was faulted in at cafebffe
[00001000] exiting gracefully
[00001000] free env 00001000
```
如果您只看到第一个“this string”行，则意味着您没有正确处理递归页面错误。

运行 `user/faultallocbad`。你应该看到：
```bash
...
[00000000] new env 00001000
[00001000] user_mem_check assertion failure for va deadbeef
[00001000] free env 00001000
```
确保您了解 `user/faultalloc` 和 `user/faultallocbad` 结果不同的原因。

不同的原因：`faultalloc`中调用的是`cprint()`访问内存来输出字符，而`faultallocbad`是调用`sys_puts()`系统调用，会在`sys_puts()`中的`user_mem_assert()`中检测失败。

## 实现写时复制Fork
通过上面的练习，现在已经可以在用户空间实现写时复制fork。

我们在 `lib/fork.c` 中为您的 `fork()` 提供了框架。与 `dumbfork()` 一样，`fork()` 应该创建一个新环境，然后扫描父环境的整个地址空间并在子环境中设置相应的页面映射。关键区别在于， `dumbfork()` 复制所有页面，而`fork()` 最初只会复制页面映射。 `fork()` 只会在其中一个环境尝试写入某个页面时复制它。

`fork()` 的基本控制流程如下：
1. 父环境使用上面实现的 `set_pgfault_handler()` 函数将 `pgfault()` 安装为 C语言 页面错误处理程序。
2. 父环境调用 `sys_exofork()` 来创建子环境。
3. 对于 `UTOP` 以下地址空间中的每个可写或写时复制页面，父环境调用 `duppage`，它应该将写时复制页面映射到子环境地址空间，然后将写时复制页面重新映射到自己的地址空间。 [注意：这个操作的顺序（即，在父页面中将页面标记为 COW 之前）很重要！你能明白为什么吗？试着想一想颠倒顺序可能会引起麻烦的具体情况。] `duppage` 设置父子环境的 `PTE`，使该页面不可写，并在“avail”字段中包含 `PTE_COW` 以区分写时复制页面和真正的只读页面。             
   但是，异常堆栈不会以这种方式重新映射。相反，您需要在子环境中为异常堆栈分配一个新页面。由于页面错误处理程序将进行实际复制，并且页面错误处理程序在异常堆栈上运行，因此异常堆栈无法进行写时复制：谁会复制它？           
   `fork()` 还需要处理存在但不可写或写时复制的页面。
4. 父环境为子环境设置用户页面错误入口点。
5. 子环境现在可以运行了，因此父环境将其标记为可运行。

每次其中一个环境写入它尚未写入过的写时复制页面时，都会发生页面错误。这是用户页面错误处理程序的控制流：
1. 内核将页面错误传到 `_pgfault_upcall`，它调用 `fork()` 的 `pgfault()` 处理程序。
2. `pgfault()` 检查故障是否为写入（检查错误代码中的 `FEC_WR`）以及页面的 `PTE` 是否标记为 `PTE_COW`。如果没有则panic。
3. `pgfault()` 分配一个映射到临时位置的新页面，并将错误页面的内容复制到其中。然后故障处理程序将新页面映射到具有读/写权限的适当地址，以代替旧的只读映射。

用户级 `lib/fork.c` 代码必须为上述几个操作查询环境的页表（例如，页面的 `PTE` 被标记为 `PTE_COW`）。内核正是为此目的在 `UVPT` 映射环境的页表。它使用了一个巧妙的映射技巧，使得查找用户代码的 `PTE` 变得容易。 `lib/entry.S` 设置了 `uvpt` 和 `uvpd` 以便您可以轻松地在 `lib/fork.c` 中查找页表信息。

> **Exercise 12** 在 `lib/fork.c` 中实现 `fork`、`duppage` 和 `pgfault`。           
> 使用 `forktree` 程序测试您的代码。它应该产生以下消息，其中穿插着“new env”、“free env”和“exiting gracefully”消息。消息可能不会按此顺序出现，并且环境 ID 可能不同。
> ```
>	1000: I am ''
>	1001: I am '0'
>	2000: I am '00'
>	2001: I am '000'
>	1002: I am '1'
>	3000: I am '11'
>	3001: I am '10'
>	4000: I am '100'
>	1003: I am '01'
>	5000: I am '010'
>	4001: I am '011'
>	2002: I am '110'
>	1004: I am '001'
>	1005: I am '111'
>	1006: I am '101'
> ```

Part B 到此结束。确保在运行 `make grade` 时通过所有Part B测试。

# Part C:抢占式多任务处理和进程间通信 (IPC)
在 lab4 的最后部分，您将修改内核以抢占不合作的环境并允许环境相互传递消息。
## 时钟中断和抢占
运行`user/spin`测试程序。这个测试程序`fork`出一个子环境，一旦它获得 CPU 的控制权，它就会进入一个死循环。父环境和内核都不会重新获得 CPU。就保护系统免受用户模式环境中的错误或恶意代码而言，这显然不是理想的情况，因为任何用户模式环境都可以通过进入无限循环并且永远不释放CPU。为了让内核抢占运行环境，强行从中夺回 CPU 的控制权，我们必须扩展 JOS 内核以支持来自时钟硬件的外部硬件中断。

### 中断规则
外部中断（即设备中断）称为 IRQ。有 16 个可能的 IRQ，编号为 0 到 15。从 IRQ 编号到 IDT 条目的映射是不固定的。 `kern/picirq.c` 中的 `pic_init` 将 IRQ 0-15 映射到 IDT 条目 `IRQ_OFFSET` 到 `IRQ_OFFSET+15`。

在 `inc/trap.h` 中，`IRQ_OFFSET` 被定义为十进制的 `32`。因此 IDT 条目 32-47 对应于 IRQ 0-15。例如，**时钟中断是 IRQ 0**。因此，`IDT[IRQ_OFFSET+0]`（即 `IDT[32]`）包含内核中时钟中断处理程序的地址。选择此 `IRQ_OFFSET` 是为了使设备中断不会与处理器异常(0-31)重叠。 （事实上​​ ，在运行 MS-DOS 的早期 PC 中，`IRQ_OFFSET` 实际上是零，这确实在处理硬件中断和处理处理器异常之间造成了巨大的混淆！）

在 JOS 中，与 xv6 Unix 相比，我们做了一个关键的简化。外部设备中断在内核中总是被禁用（和 xv6 一样，在用户空间中启用）(**即在内核中关中断**)。外部中断由 `%eflags` 寄存器的 `FL_IF` 标志位控制（参见 `inc/mmu.h`）。设置此位时，启用外部中断。虽然可以通过多种方式修改该位，但由于我们的简化，我们将仅通过在进入和离开用户模式时保存和恢复 `%eflags` 寄存器的过程来修改它。

您必须确保在用户环境运行时设置了 `FL_IF` 标志，以便在中断到达时将其传递给处理器并由您的中断代码处理。否则，中断将被屏蔽或忽略，直到重新启用中断。我们用引导加载程序的第一条指令屏蔽了中断，到目前为止我们还没有实现重新启用中断的代码。

> **Exercise 13** 修改 `kern/trapentry.S` 和 `kern/trap.c` 以初始化 IDT 中的适当条目并为 IRQ 0 到 15 提供处理程序。然后修改 `kern/env.c` 中 `env_alloc()` 中的代码以确保用户环境始终在启用中断的情况下运行。            
> 还要取消注释 `sched_halt()` 中的 `sti` 指令，以便空闲 CPU 取消屏蔽中断。            
> 调用硬件中断处理程序时，处理器从不推送错误代码。此时您可能需要重新阅读 [80386 参考手册](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)的第 9.2 节或 [IA-32 英特尔架构软件开发人员手册第 3 卷](https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf)的第 5.8 节。                 
> 做完这个练习后，如果你用任何测试程序运行你的内核，并运行一段很长的时间（例如`spin`），你应该看到内核打印硬件中断的`Trapframe`。虽然现在在处理器中启用了中断，但 JOS 尚未处理它们，因此您应该看到它将每个中断错误地归因于当前正在运行的用户环境并销毁它。最终它应该用尽环境来销毁并进入监视器中。

### 处理时钟中断
在 `user/spin` 程序中，子环境第一次运行后，就进入无限循环，内核无法拿回控制权。我们需要对硬件进行编程以定期生成时钟中断，这将强行把控制权返回给内核，然后可以在内核中将控制权交给其他用户环境。

我们为您编写的对 `lapic_init` 和 `pic_init`（来自 `init.c` 中的 `i386_init`）的调用设置时钟和中断控制器以生成中断。您现在需要编写代码来处理这些中断。

> **Exercise 14** 修改内核的 `trap_dispatch()` 函数，以便在发生时钟中断时调用 `sched_yield()` 来查找和运行不同的环境。     
> 你现在应该能够让`user/spin`测试程序工作：父环境应该fork子环境，`sys_yield()` 会调度它几次，但在每一次都在一个时间片后重新获得对 CPU 的控制，最后kill子环境并gracefully终止。

这是进行回归测试的好时机。通过启用中断，确保您没有破坏该实验室以前工作的任何部分（例如 `forktree`）。此外，尝试使用 `make CPUS=2 target` 运行多个 CPU。您现在应该也可以通过 `stresssched`。运行 `make grade` 现在应该在此实验中获得的分数为 65/80 。

## 进程间通信(IPC)
