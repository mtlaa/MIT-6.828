# Lab 5:文件系统、Spawn 和 Shell
# 引言
在本实验中，您将实现 `spawn`，这是一个加载和运行磁盘上可执行文件的库调用。然后，您将完善您的内核和库操作系统，使其在控制台上运行一个 `shell`。这些功能需要一个文件系统，本实验介绍一个简单的读/写文件系统。

## 开始
使用git把`origin/lab5`分支合并到`lab4`分支。这部分的主要新组件是文件系统环境，位于新的 `fs` 目录中。浏览此目录中的所有文件以了解所有新内容。另外，在`user`和`lib`目录下有一些新的文件系统相关的源文件。
- `fs/fs.c` 控制文件系统磁盘结构的代码。
- `fs/bc.c` 一个简单的块缓存，构建在我们的用户级页面错误处理工具之上。
- `fs/ide.c` 基于最小 PIO 的（非中断驱动）IDE 驱动程序代码。
- `fs/serv.c` 使用文件系统 IPC 与客户端环境交互的文件系统服务器。
- `lib/fd.c` 实现类 UNIX 文件描述符接口的代码。
- `lib/file.c` 磁盘文件类型的驱动程序，作为文件系统 IPC 客户端实现。
- `lib/console.c` 控制台输入/输出文件类型的驱动程序。
- `lib/spawn.c` `spawn`库调用的代码框架。

合并到新的实验 5 代码后，您应该再次运行实验 4 中的 `pingpong`、`primes` 和 `forktree` 测试用例。你需要注释掉 `kern/init.c` 中的 `ENV_CREATE(fs_fs)` 行，因为 `fs/fs.c` 试图做一些 JOS 不允许的 I/O。同样，暂时注释掉`lib/exit.c`中对`close_all()`的调用；此函数调用您稍后将在lab中实现的子例程，因此如果被调用，将会出现panic。如果您的实验 4 代码不包含任何错误，则测试用例应该可以正常运行。开始练习 1 时不要忘记取消注释这些行。

# 文件系统预备知识
您将使用的文件系统比大多数“真实”文件系统（包括 xv6 UNIX 的文件系统）简单得多，但它足够强大以提供基本功能：创建、读取、写入和删除组织在分层目录结构中的文件。

我们目前只开发一个单用户操作系统，它提供的保护足以捕获错误，但不能保护多个相互可疑的用户相互攻击。因此，我们的文件系统不支持 UNIX 的文件所有权或权限概念。我们的文件系统目前也不像大多数 UNIX 文件系统那样支持硬链接、符号链接、时间戳或特殊设备文件。

## 磁盘文件系统结构
大多数 UNIX 文件系统将可用磁盘空间划分为两种主要类型的区域：inode 区域和数据区域。 UNIX文件系统为文件系统中的每个文件分配一个inode；文件的 inode 保存关于文件的关键元数据，例如它的 `stat` 属性和指向它的数据块的指针。数据区域被划分为更大（通常为 8KB 或更大）的数据块，文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和指向 inode 的指针；如果文件系统中的多个目录条目引用该文件的索引节点，则称该文件是硬链接的。由于我们的文件系统不支持硬链接，我们不需要这种间接级别，因此可以进行方便的简化：**我们的文件系统根本不使用 inode，而是简单地用目录条目存储文件的关键元数据。**

文件和目录在逻辑上都由一系列数据块组成，这些数据块可能散布在整个磁盘中，就像环境的虚拟地址空间的页面可以散布在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了在文件内任意偏移处读取和写入字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统确实允许用户环境直接读取目录元数据（例如，使用 `read`），这意味着用户环境可以自己执行目录扫描操作（例如，实现 `ls` 程序），而不必依赖额外的特殊调用到文件系统。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，所以文件系统改变了应用程序也要改变。

### 扇区(sector)和块(block)
大多数磁盘不能以字节为单位进行读写，而是以扇区为单位进行读写。在 JOS 中，每个扇区为 512 字节。文件系统实际上以块为单位分配和使用磁盘存储。请注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。

UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间变得更便宜并且以更大的粒度管理存储更有效。我们的文件系统将使用 4096 字节的块大小（8个块,4KB），方便匹配处理器的页面大小。

### 超级块
文件系统通常在磁盘上“易于查找”的位置（例如最开始或最末端）保留某些磁盘块，以保存描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次挂载的时间、文件系统上次检查错误的时间等等。这些特殊块称为超级块。

我们的文件系统只有一个超级块，它总是位于磁盘上的块 1。它的布局由 `inc/fs.h` 中的 `struct Super` 定义。块 0 通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，复制到磁盘的几个间隔较宽的区域，因此如果其中一个损坏或磁盘在该区域出现介质错误，其他超级块仍然可以找到并用于访问文件系统。

### 文件元数据
在我们的文件系统中描述文件的元数据的布局由 `inc/fs.h` 中的 `struct File` 描述。此元数据包括文件的名称、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有索引节点(inode)，**因此此元数据存储在磁盘上的目录条目中**。与大多数“真实”文件系统不同，为简单起见，我们将使用这个`struct File`来表示文件元数据，因为它同时出现在磁盘和内存中。

`struct File` 中的 `f_direct` 数组包含文件的前 10 (`NDIRECT`) 个块的块号，我们称之为文件的直接块(直接索引)。对于大小最大为 10*4096 = 40KB 的小文件，这意味着所有文件块的块号将直接保存在`struct File`中。然而，对于较大的文件，我们需要一个地方来保存文件的其余块号。因此，对于大小超过 40KB 的任何文件，我们分配一个额外的磁盘块，称为文件的间接块（一级间接索引），以容纳最多 4096/4 = 1024 个额外的块号（一个块号占4B）。因此，我们的文件系统允许文件最大为 1034 个块，或刚好超过 4 兆字节。为了支持更大的文件，“真正的”文件系统通常也支持双重和三重间接块。

### 目录与常规文件
我们的文件系统中的`struct File`可以代表一个普通文件或一个目录；这两种类型的“文件”是通过`struct File`中的类型字段来区分的。文件系统以完全相同的方式管理常规文件和目录文件，只是它根本不解释常规文件关联的数据块的内容，而文件系统将目录文件的内容解释为一系列描述目录中的文件和子目录的`struct File`。

我们文件系统中的超级块包含一个`struct File`结构（`struct Super` 中的`root`字段），它保存文件系统根目录的元数据。该目录文件的内容是一系列`struct File`，描述文件系统根目录中的文件和目录。根目录中的任何子目录可能依次包含更多表示子子目录的`struct File`，依此类推。

# 文件系统

## 磁盘访问

