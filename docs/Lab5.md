# Lab 5:文件系统、Spawn 和 Shell
# 引言
在本实验中，您将实现 `spawn`，这是一个加载和运行磁盘上可执行文件的库调用。然后，您将完善您的内核和库操作系统，使其在控制台上运行一个 `shell`。这些功能需要一个文件系统，本实验介绍一个简单的读/写文件系统。

## 开始
使用git把`origin/lab5`分支合并到`lab4`分支。这部分的主要新组件是文件系统环境，位于新的 `fs` 目录中。浏览此目录中的所有文件以了解所有新内容。另外，在`user`和`lib`目录下有一些新的文件系统相关的源文件。
- `fs/fs.c` 控制文件系统磁盘结构的代码。
- `fs/bc.c` 一个简单的块缓存，构建在我们的用户级页面错误处理工具之上。
- `fs/ide.c` 基于最小 PIO 的（非中断驱动）IDE 驱动程序代码。
- `fs/serv.c` 使用文件系统 IPC 与客户端环境交互的文件系统服务器。
- `lib/fd.c` 实现类 UNIX 文件描述符接口的代码。
- `lib/file.c` 磁盘文件类型的驱动程序，作为文件系统 IPC 客户端实现。
- `lib/console.c` 控制台输入/输出文件类型的驱动程序。
- `lib/spawn.c` `spawn`库调用的代码框架。

合并到新的实验 5 代码后，您应该再次运行实验 4 中的 `pingpong`、`primes` 和 `forktree` 测试用例。你需要注释掉 `kern/init.c` 中的 `ENV_CREATE(fs_fs)` 行，因为 `fs/fs.c` 试图做一些 JOS 不允许的 I/O。同样，暂时注释掉`lib/exit.c`中对`close_all()`的调用；此函数调用您稍后将在lab中实现的子例程，因此如果被调用，将会出现panic。如果您的实验 4 代码不包含任何错误，则测试用例应该可以正常运行。开始练习 1 时不要忘记取消注释这些行。

# 文件系统预备知识
您将使用的文件系统比大多数“真实”文件系统（包括 xv6 UNIX 的文件系统）简单得多，但它足够强大以提供基本功能：创建、读取、写入和删除组织在分层目录结构中的文件。

我们目前只开发一个单用户操作系统，它提供的保护足以捕获错误，但不能保护多个相互可疑的用户相互攻击。因此，我们的文件系统不支持 UNIX 的文件所有权或权限概念。我们的文件系统目前也不像大多数 UNIX 文件系统那样支持硬链接、符号链接、时间戳或特殊设备文件。

## 磁盘文件系统结构
大多数 UNIX 文件系统将可用磁盘空间划分为两种主要类型的区域：inode 区域和数据区域。 UNIX文件系统为文件系统中的每个文件分配一个inode；文件的 inode 保存关于文件的关键元数据，例如它的 `stat` 属性和指向它的数据块的指针。数据区域被划分为更大（通常为 8KB 或更大）的数据块，文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和指向 inode 的指针；如果文件系统中的多个目录条目引用该文件的索引节点，则称该文件是硬链接的。由于我们的文件系统不支持硬链接，我们不需要这种间接级别，因此可以进行方便的简化：**我们的文件系统根本不使用 inode，而是简单地用目录条目存储文件的关键元数据。**

文件和目录在逻辑上都由一系列数据块组成，这些数据块可能散布在整个磁盘中，就像环境的虚拟地址空间的页面可以散布在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了在文件内任意偏移处读取和写入字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统确实允许用户环境直接读取目录元数据（例如，使用 `read`），这意味着用户环境可以自己执行目录扫描操作（例如，实现 `ls` 程序），而不必依赖额外的特殊调用到文件系统。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，所以文件系统改变了应用程序也要改变。

### 扇区(sector)和块(block)
大多数磁盘不能以字节为单位进行读写，而是以扇区为单位进行读写。在 JOS 中，每个扇区为 512 字节。文件系统实际上以块为单位分配和使用磁盘存储。请注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。

UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间变得更便宜并且以更大的粒度管理存储更有效。我们的文件系统将使用 4096 字节的块大小（8个扇区,4KB），方便匹配处理器的页面大小。

### 超级块
文件系统通常在磁盘上“易于查找”的位置（例如最开始或最末端）保留某些磁盘块，以保存描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次挂载的时间、文件系统上次检查错误的时间等等。这些特殊块称为超级块。

我们的文件系统只有一个超级块，它总是位于磁盘上的块 1。它的布局由 `inc/fs.h` 中的 `struct Super` 定义。块 0 通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，复制到磁盘的几个间隔较宽的区域，因此如果其中一个损坏或磁盘在该区域出现介质错误，其他超级块仍然可以找到并用于访问文件系统。               
![disk](https://pdos.csail.mit.edu/6.828/2018/labs/lab5/disk.png)

### 文件元数据
在我们的文件系统中描述文件的元数据的布局由 `inc/fs.h` 中的 `struct File` 描述。此元数据包括文件的名称、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有索引节点(inode)，**因此此元数据存储在磁盘上的目录条目中**。与大多数“真实”文件系统不同，为简单起见，我们将使用这个`struct File`来表示文件元数据，因为它同时出现在磁盘和内存中。

`struct File` 中的 `f_direct` 数组包含文件的前 10 (`NDIRECT`) 个块的块号，我们称之为文件的直接块(直接索引)。对于大小最大为 10*4096 = 40KB 的小文件，这意味着所有文件块的块号将直接保存在`struct File`中。然而，对于较大的文件，我们需要一个地方来保存文件的其余块号。因此，对于大小超过 40KB 的任何文件，我们分配一个额外的磁盘块，称为文件的间接块（一级间接索引），以容纳最多 4096/4 = 1024 个额外的块号（一个块号占4B）。因此，我们的文件系统允许文件最大为 1034 个块，或刚好超过 4 兆字节。为了支持更大的文件，“真正的”文件系统通常也支持双重和三重间接块。                   
![file](https://pdos.csail.mit.edu/6.828/2018/labs/lab5/file.png)

### 目录与常规文件
我们的文件系统中的`struct File`可以代表一个普通文件或一个目录；这两种类型的“文件”是通过`struct File`中的类型字段来区分的。文件系统以完全相同的方式管理常规文件和目录文件，只是它根本不解释常规文件关联的数据块的内容，而文件系统将目录文件的内容解释为一系列描述目录中的文件和子目录的`struct File`。

我们文件系统中的超级块包含一个`struct File`结构（`struct Super` 中的`root`字段），它保存文件系统根目录的元数据。该目录文件的内容是一系列`struct File`，描述文件系统根目录中的文件和目录。根目录中的任何子目录可能依次包含更多表示子子目录的`struct File`，依此类推。

# 文件系统
本实验的目标不是让您实现整个文件系统，而是让您仅实现某些关键组件。具体而言，您将负责将块读入块缓存并将它们刷新回磁盘；分配磁盘块；将文件偏移量映射到磁盘块；在IPC接口中实现读、写、打开。因为您不会自己实现所有文件系统，所以熟悉提供的代码和各种文件系统接口非常重要。

## 磁盘访问
我们操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在我们的内核中实现任何磁盘访问功能。我们没有采用传统的“单一”操作系统策略，即向内核添加 IDE 磁盘驱动程序以及必要的系统调用以允许文件系统访问它，而是将 IDE 磁盘驱动程序实现为用户级文件的一部分系统环境。我们仍然需要稍微修改内核，以便进行设置，使文件系统环境具有实现磁盘访问所需的权限。

只要我们使用依靠轮询、基于“程序化 I/O”(PIO) 的磁盘访问并且不使用磁盘中断，就可以通过这种方式轻松实现用户空间的磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序（例如，L3 和 L4 内核就是这样做的），但由于内核必须处理设备中断并将它们分派到正确的用户模式环境，所以难度更大.

x86 处理器使用 `EFLAGS` 寄存器中的 `IOPL` 位来确定是否允许保护模式代码执行特殊设备 I/O 指令，例如 `IN` 和 `OUT` 指令。由于我们需要访问的所有 IDE 磁盘寄存器都位于 x86 的 I/O 空间中，而不是内存映射，因此为文件系统环境提供“I/O 权限”是我们唯一需要做的事情允许文件系统访问这些寄存器。实际上，`EFLAGS` 寄存器中的 `IOPL` 位为内核提供了一种简单的“全有或全无”方法来控制用户模式代码是否可以访问 I/O 空间。在我们的例子中，我们希望文件系统环境能够访问 I/O 空间，但我们根本不希望任何其他环境能够访问 I/O 空间。

> **Exercise 1** `i386_init` 通过将类型 `ENV_TYPE_FS` 传递给您的环境创建函数 `env_create` 来识别文件系统环境。修改 `env.c` 中的 `env_create`，使其赋予文件系统环境 I/O 权限，但绝不会将该权限赋予任何其他环境。             
> 确保您可以启动文件系统环境而不会导致一般保护错误。您应该通过 `make grade` 中的“`fs i/o`”测试。

> **Question**         
> 1. 当您从一个环境切换到另一个环境时，您是否需要做任何其他事情来确保正确保存和恢复此 I/O 权限设置？为什么？

请注意，本实验中的 `GNUmakefile` 文件将 QEMU 设置为像以前一样使用文件 `obj/kern/kernel.img` 作为磁盘 0（通常是 DOS/Windows 下的“驱动器 C”）的映像，并使用（新）文件`obj/fs/fs.img` 作为磁盘 1（“驱动器 D”）的镜像。在本实验中，我们的文件系统应该只操作磁盘 1；磁盘 0 仅用于引导内核。如果您以某种方式损坏了任一磁盘映像，您只需键入以下内容即可将它们重置为原始的“原始”版本：
```bash
$ rm obj/kern/kernel.img obj/fs/fs.img
$ make
```
or
```bash
$ make clean
$ make
```

## 块缓存
在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“缓冲区缓存”（实际上只是一个块缓存）。块缓存的代码在 `fs/bc.c` 中。

我们的文件系统将仅限于处理 3GB 或更小的磁盘。我们保留了文件系统环境地址空间的一个大的、固定的 3GB 区域，从 0x10000000 (`DISKMAP`) 到 0xD0000000 (`DISKMAP+DISKMAX`)，作为磁盘的“内存映射”版本。例如，磁盘块 0 映射到虚拟地址 0x10000000，磁盘块 1 映射到虚拟地址 0x10001000，依此类推。 `fs/bc.c` 中的 `diskaddr` 函数实现了从磁盘块号到虚拟地址的转换（以及一些健全性检查）。

由于我们的文件系统环境有自己的虚拟地址空间，独立于系统中所有其他环境的虚拟地址空间，而文件系统环境唯一需要做的就是实现文件访问，所以以这种方式保留大部分文件系统环境的地址空间是合理的。由于现代磁盘大于 3GB，因此在 32 位机器上实现真正的文件系统会很尴尬。这种缓冲区缓存管理方法在具有 64 位地址空间的机器上可能仍然是合理的。

当然，将整个磁盘读入内存需要很长时间，因此我们将实现一种按需分页(请求分页)的形式，其中我们只在磁盘映射区域分配页面并从磁盘读取相应的块以响应该区域中的页面错误。这样，我们就可以假装整个磁盘都在内存中。

> **Exercise 2** 在 `fs/bc.c` 中实现 `bc_pgfault` 和 `flush_block` 函数。 `bc_pgfault` 是一个页面错误处理程序，除了它的工作是从磁盘加载页面以响应页面错误,就像您在上一个实验中为写时复制 fork 编写的那样。编写此代码时，请记住 (1) `addr` 可能未与块边界对齐，并且 (2) `ide_read` 以扇区为单位而不是块。                 
> `flush_block` 函数应该在必要时将块写出到磁盘。如果块甚至不在块缓存中（即页面未映射）或者它不是脏的(没有被写过)，`flush_block` 不应该做任何事情。我们将使用 VM 硬件来跟踪磁盘块自上次从磁盘读取或写入磁盘以来是否已被修改。要查看块是否需要写回，我们可以查看 `uvpt` 条目中是否设置了 `PTE_D`“脏”位。 （`PTE_D` 位由处理器设置以响应对该页的写入；参见 386 参考手册[第 5 章](http://pdos.csail.mit.edu/6.828/2011/readings/i386/s05_02.htm)中的 5.2.4.3。）将块写回磁盘后，`flush_block` 应使用 `sys_page_map` 清除 `PTE_D` 位。                
> 使用 `make grade` 来测试你的代码。您的代码应该通过“`check_bc`”、“`check_super`”和“`check_bitmap`”。

`fs/fs.c` 中的 `fs_init` 函数是使用块缓存的一个重要例子。初始化块缓存后，它只是将指针存储到`super`全局变量中的磁盘映射区域。在这一点之后，我们可以简单地从`super`结构中读取它们，就好像它们在内存中一样，我们的页面错误处理程序将在必要时从磁盘中读取它们。

可以一试
> *Challenge* 挑战！块缓存没有逐出策略。一旦一个块出现故障，它就永远不会被删除，并将永远保留在内存中。将逐出添加到缓冲区缓存。使用页表中的 `PTE_A`“访问”位（硬件在对页面进行任何访问时设置这些位），您可以跟踪磁盘块的大致使用情况，而无需修改访问磁盘映射区域的代码中的每个位置。小心脏块。

## 块位图
在 `fs_init` 设置位图指针后，我们可以将位图视为一个打包的位数组，一个位对应磁盘上的每个块。例如，请参见 `block_is_free`，它只是检查给定块是否在位图中标记为空闲(是否已经写入数据、可读)。

注意：在位图中标记为`1`说明块空闲（is free）

> **Exercise 3** 以`free_block`为模型实现`fs/fs.c`中的`alloc_block`，它应该在位图中找到一个空闲的磁盘块，标记为已使用，并返回该块的编号。分配块时，应立即使用 `flush_block` 将更改的位图块刷新到磁盘，以帮助文件系统保持一致性。             
> 使用 `make grade` 来测试你的代码。您的代码现在应该通过“`alloc_block`”。

## 文件操作
我们在 `fs/fs.c` 中提供了多种函数来实现解释和管理文件结构、扫描和管理目录文件条目以及从根目录遍历文件系统以解析所需的路径名。通读 `fs/fs.c` 中的所有代码，并确保在继续之前了解每个函数的作用。
> **Exercise 4** 实现 `file_block_walk` 和 `file_get_block`。 `file_block_walk` 从文件中的块偏移映射到 `struct File` 或间接块中该块的指针，非常类似于 `pgdir_walk` 对页表所做的。 `file_get_block` 更进一步，映射到实际的磁盘块，必要时分配一个新的块。                
> 使用 `make grade` 来测试你的代码。您的代码应通过“`file_open`”、“`file_get_block`”、“`file_flush/file_truncated/file rewrite`”和“`testfile`”。

`file_block_walk` 和 `file_get_block` 才是文件系统的主力。例如，`file_read` 和 `file_write` 只不过是调用 `file_get_block` 的顶层实现，用于在分散的块和顺序缓冲区之间复制字节。（`file_read` 和 `file_write`是在分散的块和顺序缓冲区buf之间复制字节）


## 文件系统的接口
既然我们在文件系统环境本身中拥有必要的功能，我们必须让其他希望使用该文件系统的环境可以访问它。由于其他环境无法直接调用文件系统环境中的函数，我们将通过构建在 JOS 的 IPC 机制之上的远程过程调用或 RPC 抽象来公开对文件系统环境的访问。以图形方式，这是对文件系统服务器的调用（例如，读取）的样子:
```
      Regular env           FS env
   +---------------+   +---------------+
   |      read     |   |   file_read   |
   |   (lib/fd.c)  |   |   (fs/fs.c)   |
...|.......|.......|...|.......^.......|...............
   |       v       |   |       |       | RPC mechanism
   |  devfile_read |   |  serve_read   |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |     fsipc     |   |     serve     |
   |  (lib/file.c) |   |  (fs/serv.c)  |
   |       |       |   |       ^       |
   |       v       |   |       |       |
   |   ipc_send    |   |   ipc_recv    |
   |       |       |   |       ^       |
   +-------|-------+   +-------|-------+
           |                   |
           +-------------------+
```
虚线下方的所有内容都只是从常规环境到文件系统环境获取read请求的机制。从一开始，`read`（我们提供的）在任何文件描述符上工作，并简单地分派到适当的设备读取函数，在本例中为 `devfile_read`（我们可以有更多的设备类型，如管道）。 `devfile_read` 实现专门针对磁盘文件的读取。这个和 `lib/file.c` 中的其他 `devfile_*` 函数实现了 FS 操作的客户端接口，并且都以大致相同的方式工作，将参数捆绑在请求结构中，调用 `fsipc` 发送 IPC 请求，然后解包并返回结果。 `fsipc` 函数只处理向服务器发送请求和接收回复的常见细节。

文件系统服务器代码可以在 `fs/serv.c` 中找到。它在 `serve` 函数中循环，不断地通过 IPC 接收请求，将该请求分派给适当的处理函数，然后通过 IPC 将结果发回。在读取示例中，`serve` 将分派给 `serve_read`，它将处理读取请求的 IPC 细节，例如解包请求结构，最后调用 `file_read` 以实际执行文件读取。

回想一下，JOS 的 IPC 机制允许环境发送单个 32 位数字，并且可以选择共享一个页面。要从客户端向服务器发送请求，我们使用 32 位数字作为请求类型（文件系统服务器 RPC 已编号，就像系统调用的编号方式一样）并将请求的参数存储在 `union Fsipc` 中通过 IPC 共享的页面传递。在客户端，我们总是在 `fsipcbuf` 共享页面；在服务器端，我们将传入的请求页面映射到 `fsreq` (0x0ffff000)。

服务器还通过 IPC 发回响应。我们使用 32 位数字作为函数的返回码。对于大多数 RPC，这就是它们返回的全部内容。 `FSREQ_READ` 和 `FSREQ_STAT` 也返回数据，它们只是将数据写入客户端发送请求的页面。无需在响应 IPC 中发送此页面，因为客户端首先与文件系统服务器共享了它。此外，在其响应中，`FSREQ_OPEN` 与客户端共享一个新的“`Fd page`”。我们将很快返回文件描述符页面。

> **Exercise 5** 在 `fs/serv.c` 中实现 `serve_read`。                
> `serve_read` 的繁重工作将由 `fs/fs.c` 中已经实现的 `file_read` 完成（反过来，这只是对 `file_get_block` 的一系列调用）。 `serve_read` 只需要提供文件读取的 RPC 接口即可。查看 `serve_set_size` 中的注释和代码，以大致了解服务器函数的结构。          
> 使用 `make grade` 来测试你的代码。您的代码应通过“`serve_open/file_stat/file_close`”和“`file_read`”，得分为 `70/150`。

> **Exercise 6** 在 `fs/serv.c` 中实现 `serve_write`，在 `lib/file.c` 中实现 `devfile_write`。        
> 使用 `make grade` 来测试你的代码。您的代码应该通过“`file_write`”、“`file_read after file_write`”、“`open`”和“`large file`”，得分为 `90/150`。


# Spawn 进程
我们已经为您提供了 `spawn` 的代码（请参阅 `lib/spawn.c`），它创建一个新环境，从文件系统加载一个程序映像到其中，然后启动运行该程序的子环境。然后父进程继续独立于子进程运行。 `spawn` 函数实际上就像 UNIX 中的一个 `fork`，然后是子进程中的一个直接 `exec`。

我们实现了 `spawn` 而不是 UNIX 风格的 `exec`，因为 `spawn` 更容易以“exokernel 方式”从用户空间实现，而无需内核的特殊帮助。想一想为了在用户空间中实现 `exec` 你必须做什么，并确保你理解为什么它更难。
> **Exercise 7** `spawn` 依赖于新的系统调用 `sys_env_set_trapframe` 来初始化新创建环境的状态。在 `kern/syscall.c` 中实现 `sys_env_set_trapframe`（不要忘记在 `syscall()` 中调度新的系统调用）。              
> 通过运行 `kern/init.c` 中的 `user/spawnhello` 程序来测试您的代码，该程序将尝试从文件系统中`spawn` `/hello`。        
> 使用 `make grade` 来测试你的代码。

##  fork 和 spawn 共享库状态
UNIX 文件描述符是一个通用概念，还包括管道、控制台 I/O 等。在 JOS 中，这些设备类型中的每一个都有一个对应的 `struct Dev`，带有指向实现读/写等功能的指针。对于该设备类型, `lib/fd.c` 在此之上实现通用的类 UNIX 文件描述符接口。每个 `struct Fd` 都指示其设备类型，而 `lib/fd.c` 中的大多数函数只是将操作分派给适当的 `struct Dev` 中的函数。

`lib/fd.c` 还在每个应用程序环境从 `FDTABLE` 开始的地址空间中维护文件描述符表区域。该区域为应用程序可以同时打开的最多 `MAXFD`（当前为 32）个文件描述符中的每一个保留一页（4KB）的地址空间。在任何给定时间，当且仅当相应的文件描述符正在使用时，才会映射特定的文件描述符表页面。每个文件描述符在从 `FILEDATA` 开始的区域中还有一个可选的“数据页”，设备可以选择使用这些页面。

我们希望在 `fork` 和 `spawn` 之间共享文件描述符状态，但文件描述符状态保存在用户空间内存中。现在，在 `fork` 上，内存将被标记为写时复制，因此状态将被复制而不是共享。 （这意味着环境将无法在它们自己未打开的文件中查找，并且管道将无法跨fork工作。）在`spawn`时，内存将被留下，根本不会被复制。 （实际上，`spawn`的环境从没有打开的文件描述符开始。）

我们将更改 `fork` 以了解某些内存区域由“库操作系统”使用并且应该始终共享。我们不会在某处硬编码区域列表，而是在页表条目中设置一个未使用的位`PTE_SHARE`（就像我们在 `fork` 中对 `PTE_COW` 位所做的那样）。

我们在 `inc/lib.h` 中定义了一个新的 `PTE_SHARE` 位。该位是 Intel 和 AMD 手册中标记为“可供软件使用”的三个 PTE 位之一。我们将建立一个约定，如果一个页表条目设置了这个位，则 PTE 应该在 `fork` 和 `spawn` 中直接从父级复制到子级。请注意，这与将其标记为写时复制不同：如第一段所述，我们希望确保共享页面更新。

> **Exercise 8** 更改 `lib/fork.c` 中的 `duppage` 以遵循新约定。如果页表条目设置了 `PTE_SHARE` 位，则直接复制映射即可。 （你应该使用 `PTE_SYSCALL`，而不是 `0xfff`来屏蔽掉页表条目中的相关位。`0xfff` 会包含已访问和脏的位。）         
> 同样，在 `lib/spawn.c` 中实现 `copy_shared_pa​​ges`。它应该遍历当前进程中的所有页表条目（就像 `fork` 所做的那样），将任何设置了 `PTE_SHARE` 位的页映射复制到子进程中。

使用 `make run-testpteshare` 检查您的代码是否正常运行。您应该看到“`fork handles PTE_SHARE right`”和“`spawn handles PTE_SHARE right`”的行。

使用 `make run-testfdsharing` 检查文件描述符是否正确共享。您应该看到“`read in child succeeded`”和“`read in parent succeeded`”的行。

# 键盘接口
为了让 shell 工作，我们需要一种方法来输入它。 QEMU 一直在显示我们写入 CGA 显示器和串行端口的输出，但到目前为止我们只在内核监视器中获取输入。在 QEMU 中，在图形窗口中键入的输入代表从键盘输入到 JOS，而在控制台中输入的输入显示到串行端口上的字符。 `kern/console.c` 已经包含了自实验 1 以来内核监视器使用的键盘和串行驱动程序，但现在您需要将它们附加到系统的其余部分。
> **Exercise 9** 在你的 `kern/trap.c` 中，调用 `kbd_intr` 来处理陷阱 `IRQ_OFFSET+IRQ_KBD` 和 `serial_intr` 来处理陷阱 `IRQ_OFFSET+IRQ_SERIAL`。

我们在 `lib/console.c` 中为您实现了控制台输入/输出文件类型。 `kbd_intr` 和 `serial_intr` 用最近读取的输入填充缓冲区，而控制台文件类型耗尽缓冲区（控制台文件类型默认用于标准输入/标准输出，除非用户重定向它们）。

通过运行`make run-testkbd` 并键入几行来测试您的代码。系统应该在您完成时将您的台词回显给您。尝试在控制台和图形窗口中键入，如果两者都可用的话。

# Shell
运行 `make run-icode` 或 `make run-icode-nox`。这将运行您的内核并启动 `user/icode`。 `icode execs init`，它将控制台设置为文件描述符 0 和 1（标准输入和标准输出）。然后它将生成 `sh`，shell。您应该能够运行以下命令：
```
	echo hello world | cat
	cat lorem |cat
	cat lorem |num
	cat lorem |num |num |num |num |num
	lsfd
```
请注意，用户库例程 `cprintf` 直接打印到控制台，而不使用文件描述符代码。这非常适合调试，但不适合通过管道传输到其他程序中。要将输出打印到特定的文件描述符（例如，1，标准输出），请使用 `fprintf(1, '...', ...)`。 `printf('...', ...)` 是打印到 FD 1 的快捷方式。有关示例，请参见 `user/lsfd.c`。
> **Exercise 10** shell 不支持 I/O 重定向。最好运行`sh <script`，而不必像上面那样手动输入脚本中的所有命令。为 `user/sh.c` 添加 I/O 重定向。           
> 通过在您的 shell 中键入`sh <script`来测试您的实现                
> 运行 `make run-testshell` 来测试你的 shell。 `testshell` 只是将上述命令（也可在 `fs/testshell.sh`中找到）输入 shell，然后检查输出是否与 `fs/testshell.key` 匹配。